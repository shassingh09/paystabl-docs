"use strict";(self.webpackChunkpaystabl_docs=self.webpackChunkpaystabl_docs||[]).push([[792],{7392:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"integrations/langgraph","title":"LangGraph Integration","description":"Integrate PayStabl with LangGraph workflows to enable autonomous payments within your agent graphs. Add payment nodes that handle API costs, agent compensation, and resource procurement.","source":"@site/docs/integrations/langgraph.mdx","sourceDirName":"integrations","slug":"/integrations/langgraph","permalink":"/integrations/langgraph","draft":false,"unlisted":false,"editUrl":"https://github.com/paystabl/docs/tree/main/docs/integrations/langgraph.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MCP Server Integration","permalink":"/integrations/mcp"},"next":{"title":"n8n Integration","permalink":"/integrations/n8n"}}');var r=t(4848),s=t(8453);const i={},o="LangGraph Integration",l={},c=[{value:"Quick Setup",id:"quick-setup",level:2},{value:"Core Components",id:"core-components",level:2},{value:"PaymentNode",id:"paymentnode",level:3},{value:"AgentPaymentNode",id:"agentpaymentnode",level:3},{value:"Advanced Workflows",id:"advanced-workflows",level:2},{value:"Multi-Agent Research Pipeline",id:"multi-agent-research-pipeline",level:3},{value:"Dynamic Pricing Workflow",id:"dynamic-pricing-workflow",level:3},{value:"Payment Strategies",id:"payment-strategies",level:2},{value:"Batch Processing",id:"batch-processing",level:3},{value:"Subscription Management",id:"subscription-management",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Robust Payment Handling",id:"robust-payment-handling",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Research Assistant Workflow",id:"research-assistant-workflow",level:3},{value:"Customer Service Workflow",id:"customer-service-workflow",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Cost Optimization",id:"cost-optimization",level:3},{value:"Quality Assurance",id:"quality-assurance",level:3},{value:"Monitoring and Analytics",id:"monitoring-and-analytics",level:2},{value:"Payment Analytics",id:"payment-analytics",level:3},{value:"Related Documentation",id:"related-documentation",level:2},{value:"Support",id:"support",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"langgraph-integration",children:"LangGraph Integration"})}),"\n",(0,r.jsx)(n.p,{children:"Integrate PayStabl with LangGraph workflows to enable autonomous payments within your agent graphs. Add payment nodes that handle API costs, agent compensation, and resource procurement."}),"\n",(0,r.jsx)(n.h2,{id:"quick-setup",children:"Quick Setup"}),"\n",(0,r.jsx)(n.p,{children:"Install the PayStabl LangGraph integration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"pip install paystabl-langgraph\n"})}),"\n",(0,r.jsx)(n.p,{children:"Basic workflow setup:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from langgraph import StateGraph\nfrom paystabl_langgraph import PaymentNode, AgentPaymentNode\n\n# Create your workflow state\nclass WorkflowState(TypedDict):\n    query: str\n    results: dict\n    payment_receipts: list\n\n# Initialize the graph\nworkflow = StateGraph(WorkflowState)\n\n# Add payment-enabled nodes\nworkflow.add_node("research", PaymentNode(\n    agent_id="research_agent",\n    api_url="https://premium-research.com/api",\n    price_per_call="2.50"\n))\n\nworkflow.add_node("analysis", AgentPaymentNode(\n    from_agent="coordinator",\n    to_agent="analysis_specialist", \n    amount="5.00"\n))\n'})}),"\n",(0,r.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.h3,{id:"paymentnode",children:"PaymentNode"}),"\n",(0,r.jsx)(n.p,{children:"Handles x402 API payments within workflow steps:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from paystabl_langgraph import PaymentNode\n\ndef create_research_node():\n    return PaymentNode(\n        agent_id="research_workflow",\n        name="premium_research",\n        description="Access premium research databases",\n        config={\n            "api_url": "https://research-api.com/search",\n            "method": "POST",\n            "headers": {"Content-Type": "application/json"},\n            "max_retries": 3,\n            "timeout": 30\n        }\n    )\n\n# Add to workflow\nworkflow.add_node("research", create_research_node())\n\n# Define the node behavior\ndef research_step(state: WorkflowState):\n    research_node = workflow.get_node("research")\n    \n    result = research_node.execute({\n        "query": state["query"],\n        "depth": "comprehensive"\n    })\n    \n    return {\n        "results": result["data"],\n        "payment_receipts": state["payment_receipts"] + [result["receipt"]]\n    }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"agentpaymentnode",children:"AgentPaymentNode"}),"\n",(0,r.jsx)(n.p,{children:"Facilitates payments between agents in your workflow:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from paystabl_langgraph import AgentPaymentNode\n\ndef create_collaboration_node():\n    return AgentPaymentNode(\n        from_agent="orchestrator",\n        to_agent="specialist_agent",\n        payment_logic="dynamic",  # or "fixed"\n        base_amount="3.00",\n        quality_multiplier=True\n    )\n\n# Usage in workflow\ndef delegate_task(state: WorkflowState):\n    payment_node = workflow.get_node("collaboration")\n    \n    # Calculate payment based on task complexity\n    complexity_score = analyze_task_complexity(state["task"])\n    payment_amount = payment_node.calculate_payment(complexity_score)\n    \n    # Pay the specialist\n    payment_result = payment_node.execute({\n        "amount": payment_amount,\n        "purpose": f"Task delegation: {state[\'task\'][:50]}...",\n        "metadata": {\n            "complexity": complexity_score,\n            "task_id": state["task_id"]\n        }\n    })\n    \n    return {\n        "delegation_receipt": payment_result,\n        "payment_receipts": state["payment_receipts"] + [payment_result]\n    }\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-workflows",children:"Advanced Workflows"}),"\n",(0,r.jsx)(n.h3,{id:"multi-agent-research-pipeline",children:"Multi-Agent Research Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from langgraph import StateGraph\nfrom paystabl_langgraph import PaymentNode, AgentPaymentNode, ConditionalPaymentNode\n\nclass ResearchState(TypedDict):\n    topic: str\n    research_data: dict\n    analysis: dict\n    summary: dict\n    total_cost: float\n    payment_log: list\n\ndef create_research_pipeline():\n    workflow = StateGraph(ResearchState)\n    \n    # Step 1: Premium data collection\n    workflow.add_node("data_collection", PaymentNode(\n        agent_id="research_coordinator",\n        api_url="https://academic-api.com/search",\n        price_calculator=lambda query: len(query.split()) * 0.10,  # Dynamic pricing\n        retry_policy={\n            "max_retries": 3,\n            "backoff_factor": 2,\n            "retry_on_payment_fail": True\n        }\n    ))\n    \n    # Step 2: Pay specialist for analysis\n    workflow.add_node("specialist_analysis", AgentPaymentNode(\n        from_agent="research_coordinator",\n        to_agent="domain_expert",\n        payment_logic="quality_based",\n        base_amount="8.00",\n        quality_threshold=0.8\n    ))\n    \n    # Step 3: Conditional payment for additional resources\n    workflow.add_node("additional_resources", ConditionalPaymentNode(\n        condition=lambda state: state["analysis"]["confidence"] < 0.9,\n        payment_node=PaymentNode(\n            agent_id="research_coordinator", \n            api_url="https://expert-insights.com/api",\n            amount="12.00"\n        )\n    ))\n    \n    # Step 4: Final summarization\n    workflow.add_node("summarization", AgentPaymentNode(\n        from_agent="research_coordinator",\n        to_agent="summary_specialist",\n        amount="4.00"\n    ))\n    \n    # Define workflow edges\n    workflow.add_edge("data_collection", "specialist_analysis")\n    workflow.add_edge("specialist_analysis", "additional_resources") \n    workflow.add_edge("additional_resources", "summarization")\n    \n    return workflow.compile()\n\n# Execute the workflow\nresearch_workflow = create_research_pipeline()\n\nresult = research_workflow.invoke({\n    "topic": "AI agent payment systems",\n    "total_cost": 0.0,\n    "payment_log": []\n})\n\nprint(f"Research completed. Total cost: ${result[\'total_cost\']}")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-pricing-workflow",children:"Dynamic Pricing Workflow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class DynamicPricingWorkflow:\n    def __init__(self):\n        self.workflow = StateGraph(self.WorkflowState)\n        self.setup_nodes()\n    \n    class WorkflowState(TypedDict):\n        task: str\n        complexity: float\n        urgency: float\n        quality_required: float\n        budget: float\n        results: dict\n    \n    def calculate_dynamic_price(self, state):\n        base_price = 5.00\n        complexity_multiplier = 1 + (state["complexity"] - 0.5) * 2\n        urgency_multiplier = 1 + (state["urgency"] - 0.5) * 1.5\n        quality_multiplier = 1 + (state["quality_required"] - 0.5) * 1.2\n        \n        final_price = base_price * complexity_multiplier * urgency_multiplier * quality_multiplier\n        return min(final_price, state["budget"])  # Respect budget constraints\n    \n    def setup_nodes(self):\n        # Dynamic pricing node\n        self.workflow.add_node("price_calculation", self.calculate_price_step)\n        \n        # Payment execution node\n        self.workflow.add_node("execute_payment", PaymentNode(\n            agent_id="dynamic_coordinator",\n            payment_calculator=self.calculate_dynamic_price,\n            fallback_options=[\n                {"agent": "budget_specialist", "max_amount": "3.00"},\n                {"agent": "standard_service", "max_amount": "1.50"}\n            ]\n        ))\n        \n        # Quality verification\n        self.workflow.add_node("verify_quality", self.quality_check_step)\n        \n        # Conditional refund/bonus\n        self.workflow.add_node("final_payment", ConditionalPaymentNode(\n            conditions=[\n                {\n                    "condition": lambda state: state["results"]["quality_score"] > 0.95,\n                    "action": "bonus_payment",\n                    "amount": "2.00"\n                },\n                {\n                    "condition": lambda state: state["results"]["quality_score"] < 0.6,\n                    "action": "partial_refund", \n                    "amount": "1.50"\n                }\n            ]\n        ))\n    \n    def calculate_price_step(self, state):\n        price = self.calculate_dynamic_price(state)\n        return {"calculated_price": price}\n    \n    def quality_check_step(self, state):\n        # Simulate quality assessment\n        quality_score = evaluate_result_quality(state["results"])\n        return {"quality_score": quality_score}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"payment-strategies",children:"Payment Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"batch-processing",children:"Batch Processing"}),"\n",(0,r.jsx)(n.p,{children:"Handle multiple payments efficiently:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from paystabl_langgraph import BatchPaymentNode\n\ndef create_batch_processor():\n    return BatchPaymentNode(\n        agent_id="batch_coordinator",\n        batch_size=10,\n        parallel_processing=True,\n        error_handling="continue",  # or "abort", "retry"\n        payment_configs=[\n            {\n                "type": "api_payment",\n                "url": "https://service1.com/api",\n                "amount": "1.00"\n            },\n            {\n                "type": "agent_payment", \n                "to_agent": "processor_agent",\n                "amount": "2.50"\n            }\n        ]\n    )\n\n# Usage\ndef batch_processing_step(state):\n    batch_node = workflow.get_node("batch_processor")\n    \n    results = batch_node.execute_batch([\n        {"data": item, "payment_type": "api_payment"} \n        for item in state["batch_items"]\n    ])\n    \n    return {\n        "processed_items": [r["result"] for r in results],\n        "payment_receipts": [r["receipt"] for r in results],\n        "failed_items": [r for r in results if r["status"] == "failed"]\n    }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"subscription-management",children:"Subscription Management"}),"\n",(0,r.jsx)(n.p,{children:"Handle recurring payments within workflows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from paystabl_langgraph import SubscriptionNode\n\nclass SubscriptionWorkflow:\n    def __init__(self):\n        self.subscription_node = SubscriptionNode(\n            agent_id="subscription_manager",\n            payment_schedule="monthly",\n            auto_renewal=True,\n            billing_preferences={\n                "currency": "USD",\n                "payment_method": "agent_wallet",\n                "notification_threshold": "5.00"  # Notify when balance is low\n            }\n        )\n    \n    def setup_subscription(self, service_agent, monthly_fee):\n        return self.subscription_node.create_subscription({\n            "to_agent": service_agent,\n            "amount": monthly_fee,\n            "service_name": f"Monthly service from {service_agent}",\n            "auto_renew": True,\n            "cancellation_policy": "end_of_billing_period"\n        })\n    \n    def manage_subscriptions_step(self, state):\n        active_subscriptions = self.subscription_node.get_active_subscriptions()\n        \n        for subscription in active_subscriptions:\n            if subscription["next_payment"] <= datetime.now():\n                payment_result = self.subscription_node.process_renewal(subscription["id"])\n                state["payment_log"].append(payment_result)\n        \n        return state\n'})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,r.jsx)(n.h3,{id:"robust-payment-handling",children:"Robust Payment Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from paystabl_langgraph import RobustPaymentNode\n\ndef create_fault_tolerant_node():\n    return RobustPaymentNode(\n        agent_id="resilient_agent",\n        retry_strategies=[\n            {\n                "error_type": "insufficient_funds",\n                "action": "request_funding",\n                "max_attempts": 3,\n                "delay": 60  # Wait 60 seconds between attempts\n            },\n            {\n                "error_type": "network_error",\n                "action": "exponential_backoff",\n                "max_attempts": 5,\n                "initial_delay": 1\n            },\n            {\n                "error_type": "policy_violation", \n                "action": "escalate_approval",\n                "approval_agent": "human_supervisor"\n            }\n        ],\n        fallback_options=[\n            {"service": "budget_alternative", "max_cost": "1.00"},\n            {"service": "free_tier", "max_cost": "0.00"}\n        ]\n    )\n\ndef resilient_payment_step(state):\n    payment_node = workflow.get_node("resilient_payment")\n    \n    try:\n        result = payment_node.execute_with_recovery({\n            "primary_service": "premium_api",\n            "backup_services": ["standard_api", "basic_api"],\n            "budget_constraint": state["max_budget"]\n        })\n        \n        return {\n            "service_used": result["service"],\n            "data": result["response"],\n            "cost": result["amount"],\n            "fallback_used": result["fallback_used"]\n        }\n        \n    except PaymentException as e:\n        return {\n            "error": str(e),\n            "suggested_action": e.recovery_suggestion,\n            "cost": 0\n        }\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"research-assistant-workflow",children:"Research Assistant Workflow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Complete research workflow with payments\ndef create_research_assistant():\n    workflow = StateGraph(ResearchState)\n    \n    # Literature search with payment\n    workflow.add_node("literature_search", PaymentNode(\n        agent_id="research_assistant",\n        api_url="https://academic-search.com/api",\n        price_per_query="3.50"\n    ))\n    \n    # Expert consultation via agent payment\n    workflow.add_node("expert_consultation", AgentPaymentNode(\n        from_agent="research_assistant",\n        to_agent="domain_expert",\n        amount_calculator=lambda topic: expertise_pricing[topic]\n    ))\n    \n    # Data analysis service\n    workflow.add_node("data_analysis", PaymentNode(\n        agent_id="research_assistant", \n        api_url="https://analysis-service.com/api",\n        payment_per_dataset="5.00"\n    ))\n    \n    # Final report generation\n    workflow.add_node("report_generation", AgentPaymentNode(\n        from_agent="research_assistant",\n        to_agent="technical_writer",\n        quality_based_payment=True,\n        base_amount="10.00"\n    ))\n    \n    return workflow.compile()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"customer-service-workflow",children:"Customer Service Workflow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def create_customer_service_workflow():\n    workflow = StateGraph(CustomerServiceState)\n    \n    # Sentiment analysis via paid API\n    workflow.add_node("sentiment_analysis", PaymentNode(\n        agent_id="customer_service",\n        api_url="https://sentiment-api.com/analyze",\n        price_per_request="0.25"\n    ))\n    \n    # Escalate to human agent (paid consultation)\n    workflow.add_node("human_escalation", ConditionalPaymentNode(\n        condition=lambda state: state["sentiment"]["anger"] > 0.8,\n        payment_node=AgentPaymentNode(\n            from_agent="customer_service",\n            to_agent="human_specialist",\n            amount="15.00",\n            priority="urgent"\n        )\n    ))\n    \n    # Knowledge base lookup (paid premium search)\n    workflow.add_node("knowledge_search", PaymentNode(\n        agent_id="customer_service",\n        api_url="https://knowledge-api.com/search",\n        pricing_tiers={\n            "basic": "0.50",\n            "advanced": "1.50", \n            "premium": "3.00"\n        }\n    ))\n    \n    return workflow.compile()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"cost-optimization",children:"Cost Optimization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Implement cost tracking and optimization\nclass CostOptimizedWorkflow:\n    def __init__(self, daily_budget=100.00):\n        self.daily_budget = daily_budget\n        self.current_spend = 0.0\n        self.cost_tracker = {}\n    \n    def track_cost(self, node_name, amount):\n        self.current_spend += float(amount)\n        self.cost_tracker[node_name] = self.cost_tracker.get(node_name, 0) + float(amount)\n    \n    def check_budget(self, proposed_amount):\n        return (self.current_spend + float(proposed_amount)) <= self.daily_budget\n    \n    def get_cost_summary(self):\n        return {\n            "total_spend": self.current_spend,\n            "remaining_budget": self.daily_budget - self.current_spend,\n            "spend_by_node": self.cost_tracker,\n            "budget_utilization": (self.current_spend / self.daily_budget) * 100\n        }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"quality-assurance",children:"Quality Assurance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def implement_quality_gates():\n    return QualityGateNode(\n        quality_checks=[\n            {\n                "check": "response_completeness",\n                "threshold": 0.8,\n                "action_if_fail": "request_revision"\n            },\n            {\n                "check": "accuracy_score", \n                "threshold": 0.9,\n                "action_if_fail": "escalate_to_expert"\n            }\n        ],\n        payment_adjustments={\n            "high_quality": "+20%",\n            "poor_quality": "-30%",\n            "revision_required": "-10%"\n        }\n    )\n'})}),"\n",(0,r.jsx)(n.h2,{id:"monitoring-and-analytics",children:"Monitoring and Analytics"}),"\n",(0,r.jsx)(n.h3,{id:"payment-analytics",children:"Payment Analytics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from paystabl_langgraph import PaymentAnalytics\n\nanalytics = PaymentAnalytics(workflow)\n\n# Get workflow cost analysis\ncost_analysis = analytics.get_cost_breakdown(\n    time_period="last_30_days",\n    group_by=["node", "agent", "api"]\n)\n\n# Performance metrics\nperformance = analytics.get_performance_metrics([\n    "average_cost_per_execution",\n    "cost_per_successful_outcome", \n    "payment_failure_rate",\n    "most_expensive_nodes"\n])\n\n# Budget tracking\nbudget_status = analytics.get_budget_status([\n    "daily_spend",\n    "weekly_trend", \n    "projected_monthly_cost",\n    "cost_optimization_suggestions"\n])\n'})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/tools/pay_api_endpoint",children:"PayStabl Core Tools"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/tools/pay_agent",children:"Agent Payment Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/security",children:"Security Best Practices"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://langchain-ai.github.io/langgraph/",children:"LangGraph Official Documentation"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"support",children:"Support"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/paystabl/langgraph-integration",children:"GitHub Repository"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://discord.gg/paystabl",children:"Discord Community"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"mailto:support@paystabl.com",children:"Email Support"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);