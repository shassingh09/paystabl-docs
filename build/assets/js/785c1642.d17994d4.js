"use strict";(self.webpackChunkpaystabl_docs=self.webpackChunkpaystabl_docs||[]).push([[553],{8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>o});var a=t(6540);const r={},s=a.createContext(r);function i(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),a.createElement(s.Provider,{value:e},n.children)}},8905:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"integrations/custom_frameworks","title":"Custom Framework Integration","description":"Build payment capabilities into any agentic framework using the AgentPay payment kernel.","source":"@site/docs/integrations/custom_frameworks.mdx","sourceDirName":"integrations","slug":"/integrations/custom_frameworks","permalink":"/integrations/custom_frameworks","draft":false,"unlisted":false,"editUrl":"https://github.com/paystabl/docs/tree/main/docs/integrations/custom_frameworks.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"n8n Integration","permalink":"/integrations/n8n"},"next":{"title":"Claude MCP Demo","permalink":"/examples/claude_demo"}}');var r=t(4848),s=t(8453);const i={},o="Custom Framework Integration",l={},p=[{value:"Overview",id:"overview",level:2},{value:"Integration Patterns",id:"integration-patterns",level:2},{value:"1. REST API Integration",id:"1-rest-api-integration",level:3},{value:"Authentication",id:"authentication",level:4},{value:"Core API Endpoints",id:"core-api-endpoints",level:4},{value:"2. SDK Integration",id:"2-sdk-integration",level:3},{value:"Python Framework Example",id:"python-framework-example",level:4},{value:"JavaScript/Node.js Framework Example",id:"javascriptnodejs-framework-example",level:4},{value:"3. Webhook Integration",id:"3-webhook-integration",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Transaction Validation",id:"transaction-validation",level:3},{value:"Framework-Specific Examples",id:"framework-specific-examples",level:2},{value:"Custom Agent Loop",id:"custom-agent-loop",level:3},{value:"SDK Options",id:"sdk-options",level:2},{value:"JavaScript/TypeScript SDK",id:"javascripttypescript-sdk",level:3},{value:"Python SDK",id:"python-sdk",level:3},{value:"Go SDK",id:"go-sdk",level:3},{value:"Integration Patterns",id:"integration-patterns-1",level:2},{value:"Event-Driven Architecture",id:"event-driven-architecture",level:3},{value:"Plugin Architecture",id:"plugin-architecture",level:3},{value:"Microservices Architecture",id:"microservices-architecture",level:3},{value:"Framework-Specific Examples",id:"framework-specific-examples-1",level:2},{value:"Custom React Agent UI",id:"custom-react-agent-ui",level:3},{value:"Custom Django Agent Backend",id:"custom-django-agent-backend",level:3},{value:"FastAPI Integration",id:"fastapi-integration",level:3},{value:"Testing Your Integration",id:"testing-your-integration",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Kubernetes Deployment",id:"kubernetes-deployment",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"custom-framework-integration",children:"Custom Framework Integration"})}),"\n",(0,r.jsx)(e.p,{children:"Build payment capabilities into any agentic framework using the AgentPay payment kernel."}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"This guide shows you how to integrate AgentPay's payment capabilities into any agent framework using our REST API and SDKs. Whether you're building with custom frameworks, existing platforms, or proprietary systems, these patterns will help you add autonomous payment functionality."}),"\n",(0,r.jsx)(e.h2,{id:"integration-patterns",children:"Integration Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-rest-api-integration",children:"1. REST API Integration"}),"\n",(0,r.jsx)(e.p,{children:"The most flexible way to integrate with any framework:"}),"\n",(0,r.jsx)(e.h4,{id:"authentication",children:"Authentication"}),"\n",(0,r.jsx)(e.p,{children:"All API requests require authentication using your API key:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'curl -H "Authorization: Bearer YOUR_API_KEY" \\\n     -H "Content-Type: application/json" \\\n     https://api.agentpay.ai/v1/payments\n'})}),"\n",(0,r.jsx)(e.h4,{id:"core-api-endpoints",children:"Core API Endpoints"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Send Payment"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:'POST /v1/payments\nContent-Type: application/json\nAuthorization: Bearer YOUR_API_KEY\n\n{\n  "to": "recipient_wallet_address",\n  "amount": 10.00,\n  "currency": "USD",\n  "memo": "Payment for services"\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Check Balance"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:"GET /v1/wallet/balance\nAuthorization: Bearer YOUR_API_KEY\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Payment History"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:"GET /v1/payments/history?limit=50&offset=0\nAuthorization: Bearer YOUR_API_KEY\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Create Invoice"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:'POST /v1/invoices\nContent-Type: application/json\nAuthorization: Bearer YOUR_API_KEY\n\n{\n  "amount": 25.00,\n  "currency": "USD",\n  "description": "API access fee",\n  "expires_at": "2024-02-01T00:00:00Z"\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"2-sdk-integration",children:"2. SDK Integration"}),"\n",(0,r.jsx)(e.p,{children:"Use our SDKs for easier integration:"}),"\n",(0,r.jsx)(e.h4,{id:"python-framework-example",children:"Python Framework Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from agentpay import AgentPaySDK\nimport asyncio\n\nclass PaymentCapableAgent:\n    def __init__(self, api_key: str):\n        self.agentpay = AgentPaySDK(api_key=api_key)\n\n    async def send_payment(self, recipient: str, amount: float, currency: str = "USD"):\n        """Send payment with error handling"""\n        try:\n            result = await self.agentpay.payments.send(\n                to=recipient,\n                amount=amount,\n                currency=currency\n            )\n            return {"success": True, "transaction_id": result["id"]}\n        except Exception as e:\n            return {"success": False, "error": str(e)}\n\n    async def check_funds(self, required_amount: float):\n        """Check if sufficient funds are available"""\n        balance = await self.agentpay.wallet.get_balance()\n        return balance["amount"] >= required_amount\n\n    async def payment_workflow(self, recipient: str, amount: float):\n        """Complete payment workflow with validation"""\n        # Check funds\n        if not await self.check_funds(amount):\n            return {"error": "Insufficient funds"}\n\n        # Send payment\n        result = await self.send_payment(recipient, amount)\n\n        # Log transaction\n        if result["success"]:\n            await self.log_payment(result["transaction_id"])\n\n        return result\n'})}),"\n",(0,r.jsx)(e.h4,{id:"javascriptnodejs-framework-example",children:"JavaScript/Node.js Framework Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const { AgentPaySDK } = require('@agentpay/sdk');\n\nclass PaymentAgent {\n    constructor(apiKey) {\n        this.agentpay = new AgentPaySDK({ apiKey });\n    }\n\n    async executePayment(recipient, amount, currency = 'USD') {\n        try {\n            // Validate payment\n            const balance = await this.agentpay.wallet.getBalance();\n            if (balance.amount < amount) {\n                throw new Error('Insufficient funds');\n            }\n\n            // Send payment\n            const result = await this.agentpay.payments.send({\n                to: recipient,\n                amount: amount,\n                currency: currency\n            });\n\n            return { success: true, transactionId: result.id };\n        } catch (error) {\n            return { success: false, error: error.message };\n        }\n    }\n\n    async createPaymentIntent(amount, description) {\n        return await this.agentpay.invoices.create({\n            amount: amount,\n            currency: 'USD',\n            description: description\n        });\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-webhook-integration",children:"3. Webhook Integration"}),"\n",(0,r.jsx)(e.p,{children:"Handle payment events in your framework:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"from flask import Flask, request, jsonify\nimport hmac\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/webhooks/agentpay', methods=['POST'])\ndef handle_payment_webhook():\n    # Verify webhook signature\n    signature = request.headers.get('X-AgentPay-Signature')\n    if not verify_webhook_signature(request.data, signature):\n        return jsonify({'error': 'Invalid signature'}), 401\n\n    event = request.json\n\n    if event['type'] == 'payment.completed':\n        handle_payment_completed(event['data'])\n    elif event['type'] == 'payment.failed':\n        handle_payment_failed(event['data'])\n\n    return jsonify({'status': 'received'})\n\ndef verify_webhook_signature(payload, signature):\n    expected = hmac.new(\n        WEBHOOK_SECRET.encode(),\n        payload,\n        hashlib.sha256\n    ).hexdigest()\n    return hmac.compare_digest(f\"sha256={expected}\", signature)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import asyncio\nfrom typing import Optional\n\nasync def robust_payment(\n    agent: PaymentCapableAgent,\n    recipient: str,\n    amount: float,\n    max_retries: int = 3\n) -> dict:\n    """Payment with exponential backoff retry"""\n    for attempt in range(max_retries):\n        try:\n            result = await agent.send_payment(recipient, amount)\n            if result["success"]:\n                return result\n        except Exception as e:\n            if attempt == max_retries - 1:\n                return {"success": False, "error": f"Failed after {max_retries} attempts: {str(e)}"}\n\n            # Exponential backoff\n            await asyncio.sleep(2 ** attempt)\n\n    return {"success": False, "error": "Max retries exceeded"}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"transaction-validation",children:"Transaction Validation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'async def validate_and_send_payment(\n    agent: PaymentCapableAgent,\n    recipient: str,\n    amount: float\n) -> dict:\n    """Validate payment before sending"""\n    # Validate recipient address\n    if not is_valid_wallet_address(recipient):\n        return {"error": "Invalid recipient address"}\n\n    # Validate amount\n    if amount <= 0:\n        return {"error": "Amount must be positive"}\n\n    # Check balance\n    if not await agent.check_funds(amount):\n        return {"error": "Insufficient funds"}\n\n    # Send payment\n    return await agent.send_payment(recipient, amount)\n\ndef is_valid_wallet_address(address: str) -> bool:\n    """Validate wallet address format"""\n    return address.startswith(\'0x\') and len(address) == 42\n'})}),"\n",(0,r.jsx)(e.h2,{id:"framework-specific-examples",children:"Framework-Specific Examples"}),"\n",(0,r.jsx)(e.h3,{id:"custom-agent-loop",children:"Custom Agent Loop"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'class AutonomousPaymentAgent:\n    def __init__(self, api_key: str):\n        self.agentpay = AgentPaySDK(api_key=api_key)\n        self.running = False\n\n    async def agent_loop(self):\n        """Main agent execution loop with payment capabilities"""\n        self.running = True\n\n        while self.running:\n            # Check for payment requests\n            pending_payments = await self.get_pending_payments()\n\n            for payment in pending_payments:\n                await self.process_payment_request(payment)\n\n            # Check balance periodically\n            await self.monitor_wallet_balance()\n\n            await asyncio.sleep(10)  # Check every 10 seconds\n\n    async def process_payment_request(self, payment_request):\n        """Process individual payment request"""\n        result = await self.agentpay.payments.send(\n            to=payment_request[\'recipient\'],\n            amount=payment_request[\'amount\']\n        )\n\n        # Update request status\n        await self.update_payment_status(payment_request[\'id\'], result)\n'})}),"\n",(0,r.jsx)(e.p,{children:"This flexible approach allows you to integrate AgentPay's payment capabilities into any agent framework while maintaining full control over the implementation details."}),"\n",(0,r.jsx)(e.h2,{id:"sdk-options",children:"SDK Options"}),"\n",(0,r.jsx)(e.h3,{id:"javascripttypescript-sdk",children:"JavaScript/TypeScript SDK"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"npm install @paystabl/sdk\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Basic Integration:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import { PayStablAgent } from '@paystabl/sdk';\n\nclass MyCustomAgent {\n  private paystabl: PayStablAgent;\n\n  constructor(agentId: string, config: AgentConfig) {\n    this.paystabl = new PayStablAgent({\n      agentId,\n      apiKey: config.payStablApiKey,\n      network: config.network || 'base-sepolia'\n    });\n  }\n\n  async callPaidAPI(url: string, options: RequestOptions = {}) {\n    try {\n      // Attempt payment and get headers\n      const payment = await this.paystabl.pay_api_endpoint({\n        url,\n        method: options.method || 'GET',\n        data: options.body,\n        headers: options.headers\n      });\n\n      // Make actual API call with payment header\n      const response = await fetch(url, {\n        ...options,\n        headers: {\n          ...options.headers,\n          'X-Payment': payment.xPaymentHeader\n        }\n      });\n\n      return {\n        data: await response.json(),\n        payment: payment.receipt\n      };\n\n    } catch (error) {\n      throw new PaymentError(error.message, error.code);\n    }\n  }\n\n  async payOtherAgent(toAgentId: string, amount: string, purpose: string) {\n    return await this.paystabl.pay_agent({\n      fromAgentId: this.agentId,\n      toAgentId,\n      amount,\n      purpose\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"python-sdk",children:"Python SDK"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"pip install paystabl-python\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Basic Integration:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from paystabl import PayStablAgent\nimport requests\n\nclass CustomPythonAgent:\n    def __init__(self, agent_id: str, api_key: str):\n        self.agent_id = agent_id\n        self.paystabl = PayStablAgent(\n            agent_id=agent_id,\n            api_key=api_key,\n            network="base-sepolia"\n        )\n\n    def call_paid_api(self, url: str, method="GET", data=None, headers=None):\n        try:\n            # Get payment authorization\n            payment = self.paystabl.pay_api_endpoint(\n                url=url,\n                method=method,\n                data=data,\n                headers=headers\n            )\n\n            # Make request with payment header\n            response = requests.request(\n                method=method,\n                url=url,\n                headers={\n                    **(headers or {}),\n                    "X-Payment": payment["xPaymentHeader"]\n                },\n                json=data\n            )\n\n            return {\n                "data": response.json(),\n                "payment": payment["receipt"]\n            }\n\n        except Exception as e:\n            raise PaymentException(f"Payment failed: {str(e)}")\n\n    def pay_agent(self, to_agent_id: str, amount: str, purpose: str):\n        return self.paystabl.pay_agent(\n            from_agent_id=self.agent_id,\n            to_agent_id=to_agent_id,\n            amount=amount,\n            purpose=purpose\n        )\n'})}),"\n",(0,r.jsx)(e.h3,{id:"go-sdk",children:"Go SDK"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"go get github.com/paystabl/paystabl-go\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Basic Integration:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "github.com/paystabl/paystabl-go"\n    "net/http"\n    "bytes"\n    "encoding/json"\n)\n\ntype CustomGoAgent struct {\n    AgentID   string\n    PayStabl  *paystabl.Client\n}\n\nfunc NewCustomGoAgent(agentID, apiKey string) *CustomGoAgent {\n    client := paystabl.NewClient(apiKey, paystabl.Config{\n        Network: "base-sepolia",\n    })\n\n    return &CustomGoAgent{\n        AgentID:  agentID,\n        PayStabl: client,\n    }\n}\n\nfunc (a *CustomGoAgent) CallPaidAPI(url, method string, body interface{}) (*APIResponse, error) {\n    // Get payment authorization\n    payment, err := a.PayStabl.PayAPIEndpoint(paystabl.APIPaymentRequest{\n        AgentID: a.AgentID,\n        URL:     url,\n        Method:  method,\n        Data:    body,\n    })\n    if err != nil {\n        return nil, err\n    }\n\n    // Prepare request\n    var reqBody bytes.Buffer\n    if body != nil {\n        json.NewEncoder(&reqBody).Encode(body)\n    }\n\n    req, err := http.NewRequest(method, url, &reqBody)\n    if err != nil {\n        return nil, err\n    }\n\n    // Add payment header\n    req.Header.Set("X-Payment", payment.XPaymentHeader)\n    req.Header.Set("Content-Type", "application/json")\n\n    // Execute request\n    client := &http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    var result APIResponse\n    json.NewDecoder(resp.Body).Decode(&result)\n\n    return &result, nil\n}\n\nfunc (a *CustomGoAgent) PayAgent(toAgentID, amount, purpose string) (*paystabl.PaymentReceipt, error) {\n    return a.PayStabl.PayAgent(paystabl.AgentPaymentRequest{\n        FromAgentID: a.AgentID,\n        ToAgentID:   toAgentID,\n        Amount:      amount,\n        Purpose:     purpose,\n    })\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"integration-patterns-1",children:"Integration Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"event-driven-architecture",children:"Event-Driven Architecture"}),"\n",(0,r.jsx)(e.p,{children:"Integrate PayStabl with event-driven agent systems:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import { EventEmitter } from 'events';\n\nclass EventDrivenAgent extends EventEmitter {\n  constructor(agentId: string) {\n    super();\n    this.paystabl = new PayStablAgent({ agentId });\n    this.setupPaymentHandlers();\n  }\n\n  setupPaymentHandlers() {\n    // Handle payment requests\n    this.on('api_payment_needed', async (event) => {\n      try {\n        const payment = await this.paystabl.pay_api_endpoint(event.payload);\n        this.emit('payment_completed', { \n          originalEvent: event, \n          payment \n        });\n      } catch (error) {\n        this.emit('payment_failed', { \n          originalEvent: event, \n          error \n        });\n      }\n    });\n\n    // Handle agent-to-agent payments\n    this.on('agent_payment_needed', async (event) => {\n      try {\n        const payment = await this.paystabl.pay_agent(event.payload);\n        this.emit('agent_payment_completed', { \n          originalEvent: event, \n          payment \n        });\n      } catch (error) {\n        this.emit('agent_payment_failed', { \n          originalEvent: event, \n          error \n        });\n      }\n    });\n  }\n\n  async processTask(task) {\n    // Emit payment event when needed\n    if (task.requiresPaidAPI) {\n      this.emit('api_payment_needed', {\n        id: task.id,\n        payload: {\n          url: task.apiUrl,\n          method: 'POST',\n          data: task.parameters\n        }\n      });\n    }\n  }\n}\n\n// Usage\nconst agent = new EventDrivenAgent('event_agent_001');\n\nagent.on('payment_completed', (event) => {\n  console.log('Payment successful, continuing with task...');\n  // Continue processing with payment header\n});\n\nagent.on('payment_failed', (event) => {\n  console.log('Payment failed, trying alternative...');\n  // Handle failure gracefully\n});\n"})}),"\n",(0,r.jsx)(e.h3,{id:"plugin-architecture",children:"Plugin Architecture"}),"\n",(0,r.jsx)(e.p,{children:"Create a PayStabl plugin for existing agent frameworks:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"interface AgentPlugin {\n  name: string;\n  version: string;\n  initialize(agent: any): void;\n  destroy(): void;\n}\n\nclass PayStablPlugin implements AgentPlugin {\n  name = 'paystabl';\n  version = '1.0.0';\n\n  private paystabl: PayStablAgent;\n  private agent: any;\n\n  initialize(agent: any) {\n    this.agent = agent;\n    this.paystabl = new PayStablAgent({\n      agentId: agent.id,\n      apiKey: agent.config.payStablApiKey\n    });\n\n    // Add payment methods to agent\n    agent.payForAPI = this.payForAPI.bind(this);\n    agent.payAgent = this.payAgent.bind(this);\n    agent.checkBalance = this.checkBalance.bind(this);\n\n    // Hook into agent's request pipeline\n    if (agent.addRequestMiddleware) {\n      agent.addRequestMiddleware(this.paymentMiddleware.bind(this));\n    }\n  }\n\n  async paymentMiddleware(request: any, next: Function) {\n    // Automatically handle 402 responses\n    const response = await next(request);\n\n    if (response.status === 402) {\n      console.log('402 Payment Required detected, processing payment...');\n\n      const payment = await this.paystabl.pay_api_endpoint({\n        url: request.url,\n        method: request.method,\n        data: request.body,\n        headers: request.headers\n      });\n\n      // Retry request with payment header\n      request.headers['X-Payment'] = payment.xPaymentHeader;\n      return await next(request);\n    }\n\n    return response;\n  }\n\n  async payForAPI(url: string, options = {}) {\n    return await this.paystabl.pay_api_endpoint({\n      url,\n      ...options\n    });\n  }\n\n  async payAgent(toAgentId: string, amount: string, purpose: string) {\n    return await this.paystabl.pay_agent({\n      fromAgentId: this.agent.id,\n      toAgentId,\n      amount,\n      purpose\n    });\n  }\n\n  async checkBalance() {\n    return await this.paystabl.getBalance();\n  }\n\n  destroy() {\n    // Cleanup resources\n    this.paystabl = null;\n    this.agent = null;\n  }\n}\n\n// Register plugin with your framework\nAgentFramework.registerPlugin(new PayStablPlugin());\n"})}),"\n",(0,r.jsx)(e.h3,{id:"microservices-architecture",children:"Microservices Architecture"}),"\n",(0,r.jsx)(e.p,{children:"Integrate PayStabl in a microservices environment:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// Payment Service\nclass PaymentMicroservice {\n  private paystabl: PayStablAgent;\n\n  constructor() {\n    this.paystabl = new PayStablAgent({\n      agentId: 'payment_service',\n      apiKey: process.env.PAYSTABL_API_KEY\n    });\n  }\n\n  async handleAPIPayment(req: PaymentRequest): Promise<PaymentResponse> {\n    try {\n      const payment = await this.paystabl.pay_api_endpoint({\n        url: req.url,\n        method: req.method,\n        data: req.data,\n        headers: req.headers\n      });\n\n      return {\n        success: true,\n        xPaymentHeader: payment.xPaymentHeader,\n        receipt: payment.receipt\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        code: error.code\n      };\n    }\n  }\n\n  async handleAgentPayment(req: AgentPaymentRequest): Promise<PaymentResponse> {\n    try {\n      const payment = await this.paystabl.pay_agent({\n        fromAgentId: req.fromAgentId,\n        toAgentId: req.toAgentId,\n        amount: req.amount,\n        purpose: req.purpose\n      });\n\n      return {\n        success: true,\n        txHash: payment.txHash,\n        receipt: payment.xPayStablReceipt\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        code: error.code\n      };\n    }\n  }\n}\n\n// Agent Service (uses Payment Service)\nclass AgentMicroservice {\n  private paymentService: PaymentServiceClient;\n\n  constructor() {\n    this.paymentService = new PaymentServiceClient('http://payment-service:3000');\n  }\n\n  async processTask(task: Task) {\n    if (task.requiresPayment) {\n      // Call payment microservice\n      const paymentResult = await this.paymentService.requestAPIPayment({\n        url: task.apiUrl,\n        method: 'POST',\n        data: task.parameters\n      });\n\n      if (paymentResult.success) {\n        // Use payment header for API call\n        const response = await fetch(task.apiUrl, {\n          method: 'POST',\n          headers: {\n            'X-Payment': paymentResult.xPaymentHeader,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(task.parameters)\n        });\n\n        return await response.json();\n      } else {\n        throw new Error(`Payment failed: ${paymentResult.error}`);\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"framework-specific-examples-1",children:"Framework-Specific Examples"}),"\n",(0,r.jsx)(e.h3,{id:"custom-react-agent-ui",children:"Custom React Agent UI"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import React, { useState, useEffect } from 'react';\nimport { PayStablAgent } from '@paystabl/sdk';\n\ninterface AgentUIProps {\n  agentId: string;\n  apiKey: string;\n}\n\nexport const AgentPaymentUI: React.FC<AgentUIProps> = ({ agentId, apiKey }) => {\n  const [paystabl, setPaystabl] = useState<PayStablAgent | null>(null);\n  const [balance, setBalance] = useState<string>('0');\n  const [transactions, setTransactions] = useState<any[]>([]);\n\n  useEffect(() => {\n    const agent = new PayStablAgent({ agentId, apiKey });\n    setPaystabl(agent);\n\n    // Load initial data\n    agent.getBalance().then(setBalance);\n    agent.getTransactions().then(setTransactions);\n  }, [agentId, apiKey]);\n\n  const handleAPIPayment = async (url: string) => {\n    if (!paystabl) return;\n\n    try {\n      const payment = await paystabl.pay_api_endpoint({ url });\n\n      // Update UI with payment result\n      setTransactions(prev => [...prev, payment.receipt]);\n\n      // Make actual API call\n      const response = await fetch(url, {\n        headers: { 'X-Payment': payment.xPaymentHeader }\n      });\n\n      return await response.json();\n    } catch (error) {\n      console.error('Payment failed:', error);\n    }\n  };\n\n  return (\n    <div className=\"agent-payment-ui\">\n      <div className=\"balance\">\n        Balance: ${balance}\n      </div>\n\n      <div className=\"transactions\">\n        <h3>Recent Transactions</h3>\n        {transactions.map(tx => (\n          <div key={tx.txHash} className=\"transaction\">\n            {tx.amount} - {tx.purpose}\n          </div>\n        ))}\n      </div>\n\n      <button onClick={() => handleAPIPayment('https://api.example.com/data')}>\n        Pay for Premium Data\n      </button>\n    </div>\n  );\n};\n"})}),"\n",(0,r.jsx)(e.h3,{id:"custom-django-agent-backend",children:"Custom Django Agent Backend"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# models.py\nfrom django.db import models\nfrom paystabl import PayStablAgent\n\nclass Agent(models.Model):\n    agent_id = models.CharField(max_length=100, unique=True)\n    name = models.CharField(max_length=200)\n    api_key = models.CharField(max_length=500)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def get_paystabl_client(self):\n        return PayStablAgent(\n            agent_id=self.agent_id,\n            api_key=self.api_key\n        )\n\nclass PaymentLog(models.Model):\n    agent = models.ForeignKey(Agent, on_delete=models.CASCADE)\n    amount = models.DecimalField(max_digits=10, decimal_places=2)\n    purpose = models.CharField(max_length=500)\n    tx_hash = models.CharField(max_length=200)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n# views.py\nfrom django.http import JsonResponse\nfrom django.views import View\nfrom .models import Agent, PaymentLog\n\nclass PaymentView(View):\n    def post(self, request, agent_id):\n        try:\n            agent = Agent.objects.get(agent_id=agent_id)\n            paystabl = agent.get_paystabl_client()\n\n            data = json.loads(request.body)\n\n            if data['type'] == 'api_payment':\n                result = paystabl.pay_api_endpoint(\n                    url=data['url'],\n                    method=data.get('method', 'GET'),\n                    data=data.get('payload')\n                )\n\n                # Log the payment\n                PaymentLog.objects.create(\n                    agent=agent,\n                    amount=result['receipt']['amount'],\n                    purpose=f\"API payment to {data['url']}\",\n                    tx_hash=result['receipt']['txHash']\n                )\n\n                return JsonResponse({\n                    'success': True,\n                    'payment_header': result['xPaymentHeader'],\n                    'receipt': result['receipt']\n                })\n\n            elif data['type'] == 'agent_payment':\n                result = paystabl.pay_agent(\n                    from_agent_id=agent_id,\n                    to_agent_id=data['to_agent_id'],\n                    amount=data['amount'],\n                    purpose=data['purpose']\n                )\n\n                # Log the payment\n                PaymentLog.objects.create(\n                    agent=agent,\n                    amount=data['amount'],\n                    purpose=data['purpose'],\n                    tx_hash=result['txHash']\n                )\n\n                return JsonResponse({\n                    'success': True,\n                    'tx_hash': result['txHash'],\n                    'receipt': result['xPayStablReceipt']\n                })\n\n        except Exception as e:\n            return JsonResponse({\n                'success': False,\n                'error': str(e)\n            }, status=400)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"fastapi-integration",children:"FastAPI Integration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from fastapi import FastAPI, HTTPException, BackgroundTasks\nfrom pydantic import BaseModel\nfrom paystabl import PayStablAgent\nimport asyncio\n\napp = FastAPI(title="Agent Payment API")\n\nclass APIPaymentRequest(BaseModel):\n    agent_id: str\n    url: str\n    method: str = "GET"\n    data: dict = None\n    headers: dict = None\n\nclass AgentPaymentRequest(BaseModel):\n    from_agent_id: str\n    to_agent_id: str\n    amount: str\n    purpose: str\n\nclass PaymentService:\n    def __init__(self):\n        self.agents = {}\n\n    def get_agent(self, agent_id: str) -> PayStablAgent:\n        if agent_id not in self.agents:\n            self.agents[agent_id] = PayStablAgent(\n                agent_id=agent_id,\n                api_key=os.getenv(\'PAYSTABL_API_KEY\')\n            )\n        return self.agents[agent_id]\n\npayment_service = PaymentService()\n\n@app.post("/api/pay/endpoint")\nasync def pay_api_endpoint(request: APIPaymentRequest):\n    try:\n        agent = payment_service.get_agent(request.agent_id)\n\n        result = await agent.pay_api_endpoint(\n            url=request.url,\n            method=request.method,\n            data=request.data,\n            headers=request.headers\n        )\n\n        return {\n            "success": True,\n            "payment_header": result["xPaymentHeader"],\n            "receipt": result["receipt"]\n        }\n\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n@app.post("/api/pay/agent")\nasync def pay_agent(request: AgentPaymentRequest):\n    try:\n        agent = payment_service.get_agent(request.from_agent_id)\n\n        result = await agent.pay_agent(\n            from_agent_id=request.from_agent_id,\n            to_agent_id=request.to_agent_id,\n            amount=request.amount,\n            purpose=request.purpose\n        )\n\n        return {\n            "success": True,\n            "tx_hash": result["txHash"],\n            "receipt": result["xPayStablReceipt"]\n        }\n\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n@app.get("/api/agent/{agent_id}/balance")\nasync def get_balance(agent_id: str):\n    try:\n        agent = payment_service.get_agent(agent_id)\n        balance = await agent.get_balance()\n\n        return {\n            "agent_id": agent_id,\n            "balance": balance\n        }\n\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n'})}),"\n",(0,r.jsx)(e.h2,{id:"testing-your-integration",children:"Testing Your Integration"}),"\n",(0,r.jsx)(e.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// payment.test.ts\nimport { PayStablAgent } from '@paystabl/sdk';\nimport { jest } from '@jest/globals';\n\ndescribe('PayStabl Integration', () => {\n  let agent: PayStablAgent;\n\n  beforeEach(() => {\n    agent = new PayStablAgent({\n      agentId: 'test_agent',\n      apiKey: 'test_key',\n      network: 'base-sepolia'\n    });\n  });\n\n  test('should handle API payment successfully', async () => {\n    const mockPayment = {\n      xPaymentHeader: 'mock_header',\n      receipt: {\n        txHash: 'mock_tx',\n        amount: '1.00'\n      }\n    };\n\n    jest.spyOn(agent, 'pay_api_endpoint').mockResolvedValue(mockPayment);\n\n    const result = await agent.pay_api_endpoint({\n      url: 'https://test-api.com',\n      method: 'GET'\n    });\n\n    expect(result.xPaymentHeader).toBe('mock_header');\n    expect(result.receipt.amount).toBe('1.00');\n  });\n\n  test('should handle payment failures gracefully', async () => {\n    jest.spyOn(agent, 'pay_api_endpoint').mockRejectedValue(\n      new Error('Insufficient funds')\n    );\n\n    await expect(agent.pay_api_endpoint({\n      url: 'https://test-api.com'\n    })).rejects.toThrow('Insufficient funds');\n  });\n});\n"})}),"\n",(0,r.jsx)(e.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# test_integration.py\nimport pytest\nfrom paystabl import PayStablAgent\nimport asyncio\n\n@pytest.fixture\ndef test_agent():\n    return PayStablAgent(\n        agent_id="test_agent_integration",\n        api_key=os.getenv(\'PAYSTABL_TEST_API_KEY\'),\n        network="base-sepolia"\n    )\n\n@pytest.mark.asyncio\nasync def test_end_to_end_api_payment(test_agent):\n    # Test with a real test API that supports x402\n    result = await test_agent.pay_api_endpoint(\n        url="https://test-402-api.paystabl.com/premium-data",\n        method="GET"\n    )\n\n    assert result["xPaymentHeader"] is not None\n    assert result["receipt"]["txHash"] is not None\n    assert float(result["receipt"]["amount"]) > 0\n\n@pytest.mark.asyncio \nasync def test_agent_to_agent_payment(test_agent):\n    # Test payment between test agents\n    result = await test_agent.pay_agent(\n        from_agent_id="test_agent_integration",\n        to_agent_id="test_recipient_agent",\n        amount="0.10",\n        purpose="Integration test payment"\n    )\n\n    assert result["status"] == "success"\n    assert result["txHash"] is not None\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"class RobustPaymentHandler {\n  private paystabl: PayStablAgent;\n  private retryPolicy: RetryPolicy;\n\n  constructor(agentId: string, config: PaymentConfig) {\n    this.paystabl = new PayStablAgent({ agentId, ...config });\n    this.retryPolicy = config.retryPolicy || this.defaultRetryPolicy;\n  }\n\n  async handlePaymentWithRetry(paymentFn: () => Promise<any>): Promise<any> {\n    let lastError: Error;\n\n    for (let attempt = 1; attempt <= this.retryPolicy.maxAttempts; attempt++) {\n      try {\n        return await paymentFn();\n      } catch (error) {\n        lastError = error;\n\n        if (this.isRetryableError(error) && attempt < this.retryPolicy.maxAttempts) {\n          const delay = this.calculateDelay(attempt);\n          await this.sleep(delay);\n          continue;\n        }\n\n        throw error;\n      }\n    }\n\n    throw lastError;\n  }\n\n  private isRetryableError(error: any): boolean {\n    const retryableCodes = ['NETWORK_ERROR', 'TIMEOUT', 'RATE_LIMITED'];\n    return retryableCodes.includes(error.code);\n  }\n\n  private calculateDelay(attempt: number): number {\n    return Math.min(1000 * Math.pow(2, attempt - 1), 30000); // Exponential backoff\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'interface PaymentConfig {\n  agentId: string;\n  apiKey: string;\n  network: \'mainnet\' | \'base-## Deployment Considerations\n\n### Docker Integration\n\n```dockerfile\n# Dockerfile for custom agent with PayStabl\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Install dependencies\nCOPY package*.json ./\nRUN npm ci --only=production\n\n# Copy application code\nCOPY . .\n\n# Environment variables\nENV NODE_ENV=production\nENV PAYSTABL_API_KEY=""\nENV AGENT_ID=""\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node healthcheck.js\n\nEXPOSE 3000\n\nCMD ["npm", "start"]\n'})}),"\n",(0,r.jsx)(e.h3,{id:"kubernetes-deployment",children:"Kubernetes Deployment"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'# k8s-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: custom-payment-agent\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: custom-payment-agent\n  template:\n    metadata:\n      labels:\n        app: custom-payment-agent\n    spec:\n      containers:\n      - name: agent\n        image: your-registry/custom-payment-agent:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: PAYSTABL_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: paystabl-secrets\n              key: api-key\n        - name: AGENT_ID\n          value: "k8s-payment-agent"\n        resources:\n          requests:\n            memory: "256Mi"\n            cpu: "100m"\n          limits:\n            memory: "512Mi"\n            cpu: "500m"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: paystabl-secrets\ntype: Opaque\ndata:\n  api-key: <base64-encoded-api-key>\n'})})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}}}]);