"use strict";(self.webpackChunkpaystabl_docs=self.webpackChunkpaystabl_docs||[]).push([[601],{4247:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"examples/agent_to_agent","title":"Agent-to-Agent Payment Examples","description":"This guide demonstrates how AI agents can autonomously pay each other for services, creating collaborative workflows and marketplace dynamics. Examples show real-world scenarios where agents exchange value.","source":"@site/docs/examples/agent_to_agent.mdx","sourceDirName":"examples","slug":"/examples/agent_to_agent","permalink":"/examples/agent_to_agent","draft":false,"unlisted":false,"editUrl":"https://github.com/paystabl/docs/tree/main/docs/examples/agent_to_agent.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LangGraph Payment Retry Example","permalink":"/examples/langgraph_retry"},"next":{"title":"\ud83e\udd1d Tool: pay_agent","permalink":"/tools/pay_agent"}}');var r=t(4848),i=t(8453);const s={},o="Agent-to-Agent Payment Examples",c={},l=[{value:"Basic Agent Payment",id:"basic-agent-payment",level:2},{value:"Simple Payment Between Agents",id:"simple-payment-between-agents",level:3},{value:"Payment with Service Request",id:"payment-with-service-request",level:3},{value:"Advanced Collaboration Patterns",id:"advanced-collaboration-patterns",level:2},{value:"Multi-Agent Research Pipeline",id:"multi-agent-research-pipeline",level:3},{value:"Quality-Based Payment System",id:"quality-based-payment-system",level:3},{value:"Agent Marketplace System",id:"agent-marketplace-system",level:3},{value:"Agent Communication Protocols",id:"agent-communication-protocols",level:2},{value:"Service Discovery Protocol",id:"service-discovery-protocol",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. <strong>Payment Security</strong>",id:"1-payment-security",level:3},{value:"2. <strong>Quality Assurance</strong>",id:"2-quality-assurance",level:3},{value:"3. <strong>Cost Optimization</strong>",id:"3-cost-optimization",level:3},{value:"4. <strong>Operational Excellence</strong>",id:"4-operational-excellence",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"With LangGraph",id:"with-langgraph",level:3},{value:"With n8n",id:"with-n8n",level:3},{value:"Related Documentation",id:"related-documentation",level:2},{value:"Support",id:"support",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"agent-to-agent-payment-examples",children:"Agent-to-Agent Payment Examples"})}),"\n",(0,r.jsx)(n.p,{children:"This guide demonstrates how AI agents can autonomously pay each other for services, creating collaborative workflows and marketplace dynamics. Examples show real-world scenarios where agents exchange value."}),"\n",(0,r.jsx)(n.h2,{id:"basic-agent-payment",children:"Basic Agent Payment"}),"\n",(0,r.jsx)(n.h3,{id:"simple-payment-between-agents",children:"Simple Payment Between Agents"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { PayStablAgent } from \'@paystabl/sdk\';\n\n// Coordinator agent that needs data analysis\nconst coordinatorAgent = new PayStablAgent({\n  agentId: "data_coordinator",\n  network: "base-sepolia"\n});\n\n// Specialist agent that provides analysis services  \nconst analysisAgent = new PayStablAgent({\n  agentId: "analysis_specialist",\n  network: "base-sepolia"\n});\n\nasync function basicAgentPayment() {\n  // Coordinator pays analyst for service\n  const payment = await coordinatorAgent.pay_agent({\n    fromAgentId: "data_coordinator",\n    toAgentId: "analysis_specialist", \n    amount: "5.00",\n    purpose: "Customer sentiment analysis for Q4 data"\n  });\n\n  console.log("Payment sent:", payment.txHash);\n  console.log("Receipt:", payment.xPayStablReceipt);\n  \n  return payment;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"payment-with-service-request",children:"Payment with Service Request"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'async function paymentWithServiceRequest() {\n  const serviceRequest = {\n    type: "sentiment_analysis",\n    data: {\n      text_samples: 1000,\n      languages: ["en", "es", "fr"],\n      urgency: "high"\n    },\n    deadline: "2024-01-20T15:00:00Z"\n  };\n\n  // Calculate dynamic pricing based on request complexity\n  const baseCost = 3.00;\n  const complexityMultiplier = serviceRequest.data.languages.length * 0.5;\n  const urgencyMultiplier = serviceRequest.urgency === "high" ? 1.5 : 1.0;\n  const finalAmount = (baseCost * complexityMultiplier * urgencyMultiplier).toFixed(2);\n\n  const payment = await coordinatorAgent.pay_agent({\n    fromAgentId: "data_coordinator",\n    toAgentId: "analysis_specialist",\n    amount: finalAmount,\n    purpose: `Sentiment analysis: ${serviceRequest.type}`,\n    metadata: {\n      service_request: serviceRequest,\n      pricing_breakdown: {\n        base_cost: baseCost,\n        complexity_multiplier: complexityMultiplier,\n        urgency_multiplier: urgencyMultiplier\n      }\n    }\n  });\n\n  return { payment, serviceRequest, amount: finalAmount };\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-collaboration-patterns",children:"Advanced Collaboration Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"multi-agent-research-pipeline",children:"Multi-Agent Research Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'class ResearchPipeline {\n  constructor() {\n    this.orchestrator = new PayStablAgent({\n      agentId: "research_orchestrator",\n      network: "base-sepolia"\n    });\n    \n    this.agents = {\n      data_collector: "data_collection_agent",\n      analyst: "statistical_analyst_agent", \n      writer: "technical_writer_agent",\n      reviewer: "peer_reviewer_agent"\n    };\n  }\n\n  async executeResearchProject(topic: string, budget: number) {\n    const project = {\n      id: `research_${Date.now()}`,\n      topic,\n      budget,\n      phases: [],\n      totalCost: 0\n    };\n\n    try {\n      // Phase 1: Data Collection\n      const dataPhase = await this.executePhase({\n        agent: this.agents.data_collector,\n        task: "data_collection",\n        description: `Collect research data on: ${topic}`,\n        amount: "8.00",\n        project\n      });\n      \n      // Phase 2: Statistical Analysis\n      const analysisPhase = await this.executePhase({\n        agent: this.agents.analyst,\n        task: "statistical_analysis", \n        description: `Analyze collected data for ${topic}`,\n        amount: "12.00",\n        dependencies: [dataPhase.payment.txHash],\n        project\n      });\n\n      // Phase 3: Technical Writing\n      const writingPhase = await this.executePhase({\n        agent: this.agents.writer,\n        task: "technical_writing",\n        description: `Write research report on ${topic}`,\n        amount: "10.00", \n        dependencies: [analysisPhase.payment.txHash],\n        project\n      });\n\n      // Phase 4: Peer Review\n      const reviewPhase = await this.executePhase({\n        agent: this.agents.reviewer,\n        task: "peer_review",\n        description: `Review and validate research report`,\n        amount: "6.00",\n        dependencies: [writingPhase.payment.txHash],\n        project\n      });\n\n      return {\n        success: true,\n        project,\n        totalCost: project.totalCost,\n        phases: project.phases\n      };\n\n    } catch (error) {\n      console.error("Research pipeline failed:", error);\n      return {\n        success: false,\n        error: error.message,\n        project,\n        partialCost: project.totalCost\n      };\n    }\n  }\n\n  async executePhase({ agent, task, description, amount, dependencies = [], project }) {\n    console.log(`\\n\ud83d\ude80 Starting phase: ${task}`);\n    console.log(`\ud83d\udcb0 Cost: $${amount}`);\n    \n    // Wait for dependencies if any\n    if (dependencies.length > 0) {\n      console.log(`\u23f3 Waiting for dependencies: ${dependencies.length} transactions`);\n      await this.waitForTransactions(dependencies);\n    }\n\n    // Check budget constraint\n    if (project.totalCost + parseFloat(amount) > project.budget) {\n      throw new Error(`Budget exceeded: ${project.totalCost + parseFloat(amount)} > ${project.budget}`);\n    }\n\n    // Execute payment\n    const payment = await this.orchestrator.pay_agent({\n      fromAgentId: "research_orchestrator",\n      toAgentId: agent,\n      amount,\n      purpose: description,\n      metadata: {\n        project_id: project.id,\n        phase: task,\n        dependencies\n      }\n    });\n\n    project.totalCost += parseFloat(amount);\n    \n    const phaseResult = {\n      task,\n      agent,\n      amount: parseFloat(amount),\n      payment,\n      timestamp: new Date().toISOString(),\n      status: "completed"\n    };\n\n    project.phases.push(phaseResult);\n\n    console.log(`\u2705 Phase completed: ${task}`);\n    console.log(`\ud83d\udcc4 Transaction: ${payment.txHash}`);\n    \n    return phaseResult;\n  }\n\n  async waitForTransactions(txHashes: string[]) {\n    // Simulate waiting for transaction confirmations\n    for (const txHash of txHashes) {\n      console.log(`\u23f3 Confirming transaction: ${txHash.substring(0, 10)}...`);\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n  }\n}\n\n// Usage\nasync function runResearchPipeline() {\n  const pipeline = new ResearchPipeline();\n  \n  const result = await pipeline.executeResearchProject(\n    "AI Agent Payment Systems Market Analysis",\n    50.00 // $50 budget\n  );\n\n  if (result.success) {\n    console.log("\\n\ud83c\udf89 Research pipeline completed successfully!");\n    console.log(`\ud83d\udcca Total cost: $${result.totalCost}`);\n    console.log(`\ud83d\udccb Phases completed: ${result.phases.length}`);\n  } else {\n    console.log("\\n\u274c Research pipeline failed");\n    console.log(`\ud83d\udcb8 Partial cost: $${result.partialCost}`);\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"quality-based-payment-system",children:"Quality-Based Payment System"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'class QualityBasedPaymentSystem {\n  constructor() {\n    this.paymaster = new PayStablAgent({\n      agentId: "quality_paymaster",\n      network: "base-sepolia"\n    });\n  }\n\n  async payForService(\n    provider: string,\n    service: string,\n    baseAmount: string,\n    qualityMetrics: QualityMetrics\n  ) {\n    // Calculate quality bonus/penalty\n    const qualityScore = this.calculateQualityScore(qualityMetrics);\n    const adjustment = this.calculatePaymentAdjustment(qualityScore);\n    \n    const basePayment = parseFloat(baseAmount);\n    const finalAmount = (basePayment * adjustment).toFixed(2);\n    \n    const paymentPurpose = this.generatePaymentPurpose(\n      service, \n      qualityScore, \n      adjustment,\n      qualityMetrics\n    );\n\n    const payment = await this.paymaster.pay_agent({\n      fromAgentId: "quality_paymaster",\n      toAgentId: provider,\n      amount: finalAmount,\n      purpose: paymentPurpose,\n      metadata: {\n        base_amount: baseAmount,\n        quality_score: qualityScore,\n        adjustment_factor: adjustment,\n        quality_metrics: qualityMetrics,\n        service_type: service\n      }\n    });\n\n    return {\n      payment,\n      qualityAssessment: {\n        score: qualityScore,\n        adjustment,\n        baseAmount: basePayment,\n        finalAmount: parseFloat(finalAmount),\n        metrics: qualityMetrics\n      }\n    };\n  }\n\n  calculateQualityScore(metrics: QualityMetrics): number {\n    const weights = {\n      accuracy: 0.4,\n      completeness: 0.3,\n      timeliness: 0.2,\n      presentation: 0.1\n    };\n\n    return Object.entries(weights).reduce((score, [metric, weight]) => {\n      return score + (metrics[metric] || 0) * weight;\n    }, 0);\n  }\n\n  calculatePaymentAdjustment(qualityScore: number): number {\n    // Quality score ranges from 0-1\n    if (qualityScore >= 0.95) return 1.3;  // 30% bonus for exceptional work\n    if (qualityScore >= 0.9) return 1.2;   // 20% bonus for excellent work\n    if (qualityScore >= 0.8) return 1.1;   // 10% bonus for good work\n    if (qualityScore >= 0.7) return 1.0;   // Full payment for acceptable work\n    if (qualityScore >= 0.6) return 0.9;   // 10% reduction for poor work\n    return 0.8;                             // 20% reduction for very poor work\n  }\n\n  generatePaymentPurpose(\n    service: string, \n    score: number, \n    adjustment: number,\n    metrics: QualityMetrics\n  ): string {\n    const qualityLevel = score >= 0.9 ? "Excellent" :\n                        score >= 0.8 ? "Good" :\n                        score >= 0.7 ? "Acceptable" : "Below Standard";\n    \n    const adjustmentText = adjustment > 1.0 ? \n      `+${((adjustment - 1) * 100).toFixed(0)}% quality bonus` :\n      adjustment < 1.0 ? \n      `-${((1 - adjustment) * 100).toFixed(0)}% quality penalty` :\n      "standard payment";\n\n    return `${service} delivery - ${qualityLevel} quality (${adjustmentText})`;\n  }\n}\n\ninterface QualityMetrics {\n  accuracy: number;      // 0-1 scale\n  completeness: number;  // 0-1 scale\n  timeliness: number;    // 0-1 scale\n  presentation: number;  // 0-1 scale\n}\n\n// Example usage\nasync function demonstrateQualityPayments() {\n  const paymentSystem = new QualityBasedPaymentSystem();\n\n  // High quality work\n  const excellentWork = await paymentSystem.payForService(\n    "expert_analyst_agent",\n    "Market Research Report",\n    "15.00",\n    {\n      accuracy: 0.98,\n      completeness: 0.95,\n      timeliness: 0.9,\n      presentation: 0.92\n    }\n  );\n\n  console.log("Excellent work payment:");\n  console.log(`Base: $15.00 \u2192 Final: $${excellentWork.qualityAssessment.finalAmount}`);\n  console.log(`Quality score: ${excellentWork.qualityAssessment.score.toFixed(2)}`);\n\n  // Poor quality work\n  const poorWork = await paymentSystem.payForService(\n    "basic_analyzer_agent", \n    "Quick Analysis",\n    "8.00",\n    {\n      accuracy: 0.6,\n      completeness: 0.7,\n      timeliness: 0.5,\n      presentation: 0.4\n    }\n  );\n\n  console.log("\\nPoor work payment:");\n  console.log(`Base: $8.00 \u2192 Final: $${poorWork.qualityAssessment.finalAmount}`);\n  console.log(`Quality score: ${poorWork.qualityAssessment.score.toFixed(2)}`);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"agent-marketplace-system",children:"Agent Marketplace System"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'class AgentMarketplace {\n  constructor() {\n    this.marketplace = new PayStablAgent({\n      agentId: "marketplace_coordinator",\n      network: "base-sepolia"\n    });\n    \n    this.serviceRegistry = new Map();\n    this.activeContracts = new Map();\n  }\n\n  registerService(agentId: string, serviceDetails: ServiceListing) {\n    this.serviceRegistry.set(agentId, {\n      ...serviceDetails,\n      agentId,\n      registeredAt: new Date(),\n      rating: serviceDetails.rating || 0,\n      completedJobs: serviceDetails.completedJobs || 0\n    });\n  }\n\n  async findBestProvider(serviceType: string, requirements: ServiceRequirements) {\n    const providers = Array.from(this.serviceRegistry.values())\n      .filter(service => service.type === serviceType)\n      .filter(service => this.meetsRequirements(service, requirements))\n      .sort((a, b) => this.calculateProviderScore(b) - this.calculateProviderScore(a));\n\n    return providers[0] || null;\n  }\n\n  async createServiceContract(\n    clientId: string,\n    providerId: string, \n    serviceDetails: ContractDetails\n  ): Promise<ServiceContract> {\n    const contract = {\n      id: `contract_${Date.now()}`,\n      clientId,\n      providerId,\n      serviceDetails,\n      status: "pending",\n      createdAt: new Date(),\n      milestones: serviceDetails.milestones || [],\n      totalAmount: serviceDetails.amount,\n      escrowAmount: 0\n    };\n\n    // Calculate escrow amount (typically 50% upfront)\n    const escrowAmount = (parseFloat(serviceDetails.amount) * 0.5).toFixed(2);\n    \n    // Create escrow payment\n    const escrowPayment = await this.marketplace.pay_agent({\n      fromAgentId: clientId,\n      toAgentId: "marketplace_coordinator", // Marketplace holds escrow\n      amount: escrowAmount,\n      purpose: `Escrow for contract ${contract.id}`,\n      metadata: {\n        contract_id: contract.id,\n        type: "escrow",\n        release_conditions: serviceDetails.milestones\n      }\n    });\n\n    contract.escrowAmount = parseFloat(escrowAmount);\n    contract.escrowTxHash = escrowPayment.txHash;\n    contract.status = "active";\n\n    this.activeContracts.set(contract.id, contract);\n\n    return contract;\n  }\n\n  async releaseMilestonePayment(\n    contractId: string,\n    milestoneIndex: number,\n    clientApproval: boolean\n  ) {\n    const contract = this.activeContracts.get(contractId);\n    if (!contract) throw new Error("Contract not found");\n\n    const milestone = contract.milestones[milestoneIndex];\n    if (!milestone) throw new Error("Milestone not found");\n\n    if (!clientApproval) {\n      throw new Error("Client approval required for milestone payment");\n    }\n\n    // Release milestone payment\n    const payment = await this.marketplace.pay_agent({\n      fromAgentId: "marketplace_coordinator",\n      toAgentId: contract.providerId,\n      amount: milestone.amount,\n      purpose: `Milestone ${milestoneIndex + 1} payment for contract ${contractId}`,\n      metadata: {\n        contract_id: contractId,\n        milestone_index: milestoneIndex,\n        type: "milestone_release"\n      }\n    });\n\n    // Update contract status\n    milestone.status = "completed";\n    milestone.releasedAt = new Date();\n    milestone.txHash = payment.txHash;\n\n    // Check if all milestones completed\n    const allCompleted = contract.milestones.every(m => m.status === "completed");\n    if (allCompleted) {\n      contract.status = "completed";\n      await this.updateProviderRating(contract);\n    }\n\n    return payment;\n  }\n\n  calculateProviderScore(provider: ServiceProvider): number {\n    const ratingWeight = 0.4;\n    const experienceWeight = 0.3;\n    const priceWeight = 0.2;\n    const availabilityWeight = 0.1;\n\n    const ratingScore = provider.rating / 5; // Normalize to 0-1\n    const experienceScore = Math.min(provider.completedJobs / 100, 1); // Cap at 100 jobs\n    const priceScore = 1 - (provider.pricePerHour / 50); // Assuming $50/hour max\n    const availabilityScore = provider.available ? 1 : 0;\n\n    return (\n      ratingScore * ratingWeight +\n      experienceScore * experienceWeight +\n      priceScore * priceWeight +\n      availabilityScore * availabilityWeight\n    );\n  }\n\n  meetsRequirements(service: ServiceProvider, requirements: ServiceRequirements): boolean {\n    if (requirements.minRating && service.rating < requirements.minRating) return false;\n    if (requirements.maxPricePerHour && service.pricePerHour > requirements.maxPricePerHour) return false;\n    if (requirements.requiredSkills) {\n      const hasAllSkills = requirements.requiredSkills.every(skill => \n        service.skills.includes(skill)\n      );\n      if (!hasAllSkills) return false;\n    }\n    if (requirements.maxDeliveryTime && service.estimatedDeliveryDays > requirements.maxDeliveryTime) return false;\n\n    return true;\n  }\n\n  async updateProviderRating(contract: ServiceContract) {\n    const provider = this.serviceRegistry.get(contract.providerId);\n    if (!provider) return;\n\n    // Simple rating update (in real system, would be based on client feedback)\n    provider.completedJobs += 1;\n    \n    // Update rating based on contract performance\n    const contractRating = this.calculateContractRating(contract);\n    provider.rating = (provider.rating * (provider.completedJobs - 1) + contractRating) / provider.completedJobs;\n  }\n\n  calculateContractRating(contract: ServiceContract): number {\n    // Simple rating based on timely completion\n    const completedOnTime = contract.milestones.every(milestone => {\n      if (!milestone.releasedAt) return false;\n      return milestone.releasedAt <= milestone.dueDate;\n    });\n\n    return completedOnTime ? 5.0 : 3.5; // 5 stars for on-time, 3.5 for late\n  }\n}\n\ninterface ServiceListing {\n  type: string;\n  name: string;\n  description: string;\n  pricePerHour: number;\n  skills: string[];\n  estimatedDeliveryDays: number;\n  available: boolean;\n  rating?: number;\n  completedJobs?: number;\n}\n\ninterface ServiceRequirements {\n  minRating?: number;\n  maxPricePerHour?: number;\n  requiredSkills?: string[];\n  maxDeliveryTime?: number;\n}\n\ninterface ContractDetails {\n  description: string;\n  amount: string;\n  milestones: Milestone[];\n  deadline: Date;\n}\n\ninterface Milestone {\n  description: string;\n  amount: string;\n  dueDate: Date;\n  status: "pending" | "completed";\n  releasedAt?: Date;\n  txHash?: string;\n}\n\ninterface ServiceContract {\n  id: string;\n  clientId: string;\n  providerId: string;\n  serviceDetails: ContractDetails;\n  status: "pending" | "active" | "completed" | "disputed";\n  createdAt: Date;\n  milestones: Milestone[];\n  totalAmount: string;\n  escrowAmount: number;\n  escrowTxHash?: string;\n}\n\ninterface ServiceProvider {\n  agentId: string;\n  type: string;\n  name: string;\n  description: string;\n  pricePerHour: number;\n  skills: string[];\n  estimatedDeliveryDays: number;\n  available: boolean;\n  rating: number;\n  completedJobs: number;\n  registeredAt: Date;\n}\n\n// Example marketplace usage\nasync function demonstrateMarketplace() {\n  const marketplace = new AgentMarketplace();\n\n  // Register service providers\n  marketplace.registerService("data_analyst_pro", {\n    type: "data_analysis",\n    name: "Professional Data Analyst",\n    description: "Expert statistical analysis and visualization",\n    pricePerHour: 25,\n    skills: ["statistical_analysis", "data_visualization", "python", "r"],\n    estimatedDeliveryDays: 3,\n    available: true,\n    rating: 4.8,\n    completedJobs: 45\n  });\n\n  marketplace.registerService("content_writer_ai", {\n    type: "content_creation",\n    name: "AI Content Specialist", \n    description: "High-quality content creation and editing",\n    pricePerHour: 15,\n    skills: ["copywriting", "editing", "seo", "research"],\n    estimatedDeliveryDays: 2,\n    available: true,\n    rating: 4.6,\n    completedJobs: 32\n  });\n\n  // Find best provider for a job\n  const bestAnalyst = await marketplace.findBestProvider("data_analysis", {\n    minRating: 4.5,\n    maxPricePerHour: 30,\n    requiredSkills: ["statistical_analysis", "python"],\n    maxDeliveryTime: 5\n  });\n\n  console.log("Best analyst found:", bestAnalyst?.name);\n\n  if (bestAnalyst) {\n    // Create contract\n    const contract = await marketplace.createServiceContract(\n      "research_coordinator",\n      bestAnalyst.agentId,\n      {\n        description: "Market analysis for Q1 data",\n        amount: "75.00",\n        deadline: new Date("2024-02-01"),\n        milestones: [\n          {\n            description: "Data collection and cleaning",\n            amount: "25.00",\n            dueDate: new Date("2024-01-25"),\n            status: "pending"\n          },\n          {\n            description: "Statistical analysis", \n            amount: "30.00",\n            dueDate: new Date("2024-01-28"),\n            status: "pending"\n          },\n          {\n            description: "Final report and visualization",\n            amount: "20.00",\n            dueDate: new Date("2024-02-01"),\n            status: "pending"\n          }\n        ]\n      }\n    );\n\n    console.log("Contract created:", contract.id);\n    console.log("Escrow amount:", contract.escrowAmount);\n\n    // Simulate milestone completion and payment\n    await marketplace.releaseMilestonePayment(contract.id, 0, true);\n    console.log("Milestone 1 payment released");\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"agent-communication-protocols",children:"Agent Communication Protocols"}),"\n",(0,r.jsx)(n.h3,{id:"service-discovery-protocol",children:"Service Discovery Protocol"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'class AgentDiscoveryProtocol {\n  constructor() {\n    this.registry = new Map();\n    this.heartbeat = new Map();\n  }\n\n  async announceService(agentId: string, capabilities: AgentCapabilities) {\n    const announcement = {\n      agentId,\n      capabilities,\n      timestamp: new Date(),\n      endpoint: capabilities.endpoint,\n      pricing: capabilities.pricing\n    };\n\n    this.registry.set(agentId, announcement);\n    this.startHeartbeat(agentId);\n\n    // Broadcast announcement to other agents\n    await this.broadcastServiceAnnouncement(announcement);\n  }\n\n  async discoverServices(requirements: ServiceRequirements): Promise<AgentCapabilities[]> {\n    const availableServices = Array.from(this.registry.values())\n      .filter(service => this.isAgentAlive(service.agentId))\n      .filter(service => this.matchesRequirements(service.capabilities, requirements))\n      .sort((a, b) => this.rankService(b.capabilities) - this.rankService(a.capabilities));\n\n    return availableServices.map(service => service.capabilities);\n  }\n\n  async requestService(\n    clientId: string, \n    providerId: string, \n    serviceRequest: ServiceRequest\n  ): Promise<ServiceResponse> {\n    const provider = this.registry.get(providerId);\n    if (!provider) {\n      throw new Error("Provider not found");\n    }\n\n    // Send service request\n    const request = {\n      id: `req_${Date.now()}`,\n      clientId,\n      providerId,\n      serviceRequest,\n      timestamp: new Date()\n    };\n\n    // Calculate estimated cost\n    const estimatedCost = this.calculateServiceCost(\n      provider.capabilities, \n      serviceRequest\n    );\n\n    // Return service response with payment details\n    return {\n      requestId: request.id,\n      providerId,\n      estimatedCost,\n      estimatedDelivery: new Date(Date.now() + provider.capabilities.estimatedDeliveryMs),\n      paymentRequired: true,\n      paymentAddress: provider.capabilities.paymentAddress\n    };\n  }\n\n  private calculateServiceCost(\n    capabilities: AgentCapabilities, \n    request: ServiceRequest\n  ): string {\n    const baseRate = capabilities.pricing.baseRate;\n    const complexity = request.complexity || 1;\n    const urgency = request.urgency === "high" ? 1.5 : 1.0;\n\n    return (baseRate * complexity * urgency).toFixed(2);\n  }\n\n  private rankService(capabilities: AgentCapabilities): number {\n    // Simple ranking based on price and quality\n    const priceScore = 100 / capabilities.pricing.baseRate; // Lower price = higher score\n    const qualityScore = capabilities.qualityRating * 20;\n    \n    return priceScore + qualityScore;\n  }\n\n  private isAgentAlive(agentId: string): boolean {\n    const lastHeartbeat = this.heartbeat.get(agentId);\n    if (!lastHeartbeat) return false;\n    \n    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n    return lastHeartbeat > fiveMinutesAgo;\n  }\n\n  private startHeartbeat(agentId: string) {\n    const interval = setInterval(() => {\n      this.heartbeat.set(agentId, new Date());\n    }, 60000); // Every minute\n\n    // Clean up interval when agent disconnects\n    setTimeout(() => {\n      clearInterval(interval);\n      this.registry.delete(agentId);\n      this.heartbeat.delete(agentId);\n    }, 10 * 60 * 1000); // 10 minutes timeout\n  }\n}\n\ninterface AgentCapabilities {\n  agentId: string;\n  name: string;\n  description: string;\n  serviceTypes: string[];\n  endpoint: string;\n  pricing: {\n    baseRate: number;\n    currency: string;\n    billingModel: "per_request" | "per_hour" | "per_result";\n  };\n  qualityRating: number;\n  estimatedDeliveryMs: number;\n  paymentAddress: string;\n}\n\ninterface ServiceRequest {\n  type: string;\n  parameters: any;\n  complexity?: number;\n  urgency?: "low" | "normal" | "high";\n  deadline?: Date;\n}\n\ninterface ServiceResponse {\n  requestId: string;\n  providerId: string;\n  estimatedCost: string;\n  estimatedDelivery: Date;\n  paymentRequired: boolean;\n  paymentAddress: string;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.h3,{id:"1-payment-security",children:["1. ",(0,r.jsx)(n.strong,{children:"Payment Security"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Always verify agent identity before payments"}),"\n",(0,r.jsx)(n.li,{children:"Use escrow for larger transactions"}),"\n",(0,r.jsx)(n.li,{children:"Implement dispute resolution mechanisms"}),"\n",(0,r.jsx)(n.li,{children:"Monitor for suspicious payment patterns"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-quality-assurance",children:["2. ",(0,r.jsx)(n.strong,{children:"Quality Assurance"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement quality-based payment adjustments"}),"\n",(0,r.jsx)(n.li,{children:"Use reputation systems for agent ranking"}),"\n",(0,r.jsx)(n.li,{children:"Require deliverable validation before full payment"}),"\n",(0,r.jsx)(n.li,{children:"Maintain service level agreements"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-cost-optimization",children:["3. ",(0,r.jsx)(n.strong,{children:"Cost Optimization"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use tiered pricing based on service complexity"}),"\n",(0,r.jsx)(n.li,{children:"Implement bulk payment discounts"}),"\n",(0,r.jsx)(n.li,{children:"Monitor and optimize payment gas costs"}),"\n",(0,r.jsx)(n.li,{children:"Track ROI for agent collaborations"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"4-operational-excellence",children:["4. ",(0,r.jsx)(n.strong,{children:"Operational Excellence"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement comprehensive logging and monitoring"}),"\n",(0,r.jsx)(n.li,{children:"Use circuit breakers for failing agents"}),"\n",(0,r.jsx)(n.li,{children:"Maintain service discovery and health checks"}),"\n",(0,r.jsx)(n.li,{children:"Plan for agent failure and recovery scenarios"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"with-langgraph",children:"With LangGraph"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from langgraph import StateGraph\nfrom paystabl import PayStablAgent\n\ndef create_agent_collaboration_graph():\n    workflow = StateGraph(CollaborationState)\n    \n    workflow.add_node("find_specialist", find_specialist_agent)\n    workflow.add_node("negotiate_price", negotiate_service_price)\n    workflow.add_node("pay_agent", execute_agent_payment)\n    workflow.add_node("monitor_delivery", monitor_service_delivery)\n    \n    return workflow.compile()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"with-n8n",children:"With n8n"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "nodes": [\n    {\n      "name": "Find Agent",\n      "type": "n8n-nodes-base.httpRequest",\n      "parameters": {\n        "url": "https://agent-registry.com/search",\n        "method": "POST"\n      }\n    },\n    {\n      "name": "Pay Agent",\n      "type": "n8n-nodes-paystabl.agent-payment",\n      "parameters": {\n        "fromAgentId": "{{ $json.clientAgent }}",\n        "toAgentId": "{{ $json.selectedAgent }}",\n        "amount": "{{ $json.agreedPrice }}"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/tools/pay_agent",children:"Payment Tools Reference"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/security",children:"Security Guidelines"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/integrations/mcp",children:"Integration Frameworks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/architecture",children:"Architecture Overview"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"support",children:"Support"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://discord.gg/paystabl",children:"Discord Community"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://marketplace.paystabl.com",children:"Agent Marketplace"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/paystabl/agent-examples",children:"GitHub Examples"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"mailto:support@paystabl.com",children:"Email Support"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);