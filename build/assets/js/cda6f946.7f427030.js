"use strict";(self.webpackChunkpaystabl_docs=self.webpackChunkpaystabl_docs||[]).push([[698],{3646:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"examples/langgraph_retry","title":"LangGraph Payment Retry Example","description":"This example demonstrates how to implement robust payment retry logic in LangGraph workflows using PayStabl. It shows how to handle payment failures gracefully and implement different retry strategies.","source":"@site/docs/examples/langgraph_retry.mdx","sourceDirName":"examples","slug":"/examples/langgraph_retry","permalink":"/examples/langgraph_retry","draft":false,"unlisted":false,"editUrl":"https://github.com/paystabl/docs/tree/main/docs/examples/langgraph_retry.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Claude MCP Demo","permalink":"/examples/claude_demo"},"next":{"title":"Agent-to-Agent Payment Examples","permalink":"/examples/agent_to_agent"}}');var a=n(4848),s=n(8453);const i={},l="LangGraph Payment Retry Example",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Retry Workflow",id:"basic-retry-workflow",level:2},{value:"Key Features Demonstrated",id:"key-features-demonstrated",level:2},{value:"1. <strong>Intelligent Retry Logic</strong>",id:"1-intelligent-retry-logic",level:3},{value:"2. <strong>Service Fallback Chain</strong>",id:"2-service-fallback-chain",level:3},{value:"3. <strong>Error Categorization</strong>",id:"3-error-categorization",level:3},{value:"4. <strong>Cost Management</strong>",id:"4-cost-management",level:3},{value:"5. <strong>Comprehensive Logging</strong>",id:"5-comprehensive-logging",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Retry Workflow",id:"basic-retry-workflow-1",level:3},{value:"Advanced Configuration",id:"advanced-configuration",level:3},{value:"Integration with Monitoring",id:"integration-with-monitoring",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. <strong>Service Hierarchy Design</strong>",id:"1-service-hierarchy-design",level:3},{value:"2. <strong>Error Handling Strategy</strong>",id:"2-error-handling-strategy",level:3},{value:"3. <strong>Cost Optimization</strong>",id:"3-cost-optimization",level:3},{value:"4. <strong>Quality Assurance</strong>",id:"4-quality-assurance",level:3},{value:"5. <strong>Monitoring and Analytics</strong>",id:"5-monitoring-and-analytics",level:3},{value:"Related Documentation",id:"related-documentation",level:2},{value:"Support",id:"support",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"langgraph-payment-retry-example",children:"LangGraph Payment Retry Example"})}),"\n",(0,a.jsx)(t.p,{children:"This example demonstrates how to implement robust payment retry logic in LangGraph workflows using PayStabl. It shows how to handle payment failures gracefully and implement different retry strategies."}),"\n",(0,a.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(t.p,{children:"This workflow implements:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Payment retry mechanisms"})," for failed transactions"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Exponential backoff"})," for network-related failures"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Alternative payment paths"})," when primary methods fail"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Fallback services"})," when expensive options are unavailable"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cost optimization"})," through smart retry logic"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"basic-retry-workflow",children:"Basic Retry Workflow"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'from langgraph import StateGraph\nfrom paystabl import PayStablAgent\nimport asyncio\nfrom typing import TypedDict, List\nfrom enum import Enum\n\nclass RetryStrategy(Enum):\n    EXPONENTIAL_BACKOFF = "exponential"\n    LINEAR_BACKOFF = "linear"\n    IMMEDIATE = "immediate"\n    ALTERNATIVE_SERVICE = "alternative"\n\nclass WorkflowState(TypedDict):\n    task: str\n    payment_attempts: List[dict]\n    current_service: str\n    retry_count: int\n    max_retries: int\n    fallback_services: List[str]\n    result: dict\n    error: str\n    total_cost: float\n\nclass PaymentRetryWorkflow:\n    def __init__(self, agent_id: str):\n        self.agent = PayStablAgent(\n            agent_id=agent_id,\n            network="base-sepolia"\n        )\n        self.workflow = self.build_workflow()\n    \n    def build_workflow(self) -> StateGraph:\n        workflow = StateGraph(WorkflowState)\n        \n        # Core workflow nodes\n        workflow.add_node("validate_request", self.validate_request)\n        workflow.add_node("attempt_payment", self.attempt_payment)\n        workflow.add_node("handle_failure", self.handle_payment_failure)\n        workflow.add_node("retry_with_backoff", self.retry_with_backoff)\n        workflow.add_node("try_alternative", self.try_alternative_service)\n        workflow.add_node("use_fallback", self.use_fallback_service)\n        workflow.add_node("complete_task", self.complete_task)\n        workflow.add_node("final_failure", self.handle_final_failure)\n        \n        # Define workflow edges\n        workflow.add_edge("validate_request", "attempt_payment")\n        workflow.add_conditional_edges(\n            "attempt_payment",\n            self.route_payment_result,\n            {\n                "success": "complete_task",\n                "retry": "handle_failure",\n                "failed": "final_failure"\n            }\n        )\n        workflow.add_conditional_edges(\n            "handle_failure",\n            self.route_failure_handling,\n            {\n                "backoff": "retry_with_backoff",\n                "alternative": "try_alternative",\n                "fallback": "use_fallback",\n                "give_up": "final_failure"\n            }\n        )\n        workflow.add_edge("retry_with_backoff", "attempt_payment")\n        workflow.add_edge("try_alternative", "attempt_payment")\n        workflow.add_edge("use_fallback", "attempt_payment")\n        \n        return workflow.compile()\n    \n    async def validate_request(self, state: WorkflowState) -> WorkflowState:\n        """Validate the payment request and set up retry parameters"""\n        \n        # Initialize retry parameters\n        state["payment_attempts"] = []\n        state["retry_count"] = 0\n        state["max_retries"] = 5\n        state["total_cost"] = 0.0\n        \n        # Define service hierarchy (expensive to cheap)\n        state["fallback_services"] = [\n            "premium_ai_service",    # $10.00 - Best quality\n            "standard_ai_service",   # $5.00 - Good quality  \n            "basic_ai_service",      # $2.00 - Adequate quality\n            "free_service"           # $0.00 - Basic quality\n        ]\n        \n        # Start with the best service\n        state["current_service"] = state["fallback_services"][0]\n        \n        print(f"\ud83d\udd0d Validating request for task: {state[\'task\']}")\n        print(f"\ud83c\udfaf Starting with service: {state[\'current_service\']}")\n        \n        return state\n    \n    async def attempt_payment(self, state: WorkflowState) -> WorkflowState:\n        """Attempt payment for the current service"""\n        \n        service_config = self.get_service_config(state["current_service"])\n        attempt_info = {\n            "attempt": state["retry_count"] + 1,\n            "service": state["current_service"],\n            "amount": service_config["cost"],\n            "timestamp": datetime.now().isoformat()\n        }\n        \n        print(f"\ud83d\udcb3 Payment attempt #{attempt_info[\'attempt\']} for {service_config[\'name\']}")\n        print(f"\ud83d\udcb0 Cost: ${service_config[\'cost\']}")\n        \n        try:\n            # Check if this is a free service\n            if service_config["cost"] == "0.00":\n                state["result"] = await self.call_free_service(service_config, state["task"])\n                attempt_info["status"] = "success"\n                attempt_info["method"] = "free_service"\n            else:\n                # Attempt paid service\n                payment_result = await self.agent.pay_api_endpoint(\n                    url=service_config["url"],\n                    method="POST",\n                    data={"task": state["task"]},\n                    timeout=30\n                )\n                \n                state["result"] = payment_result["data"]\n                state["total_cost"] += float(service_config["cost"])\n                \n                attempt_info["status"] = "success"\n                attempt_info["tx_hash"] = payment_result["receipt"]["txHash"]\n                attempt_info["method"] = "paystabl_payment"\n            \n            print(f"\u2705 Payment successful!")\n            \n        except Exception as error:\n            print(f"\u274c Payment failed: {error}")\n            \n            attempt_info["status"] = "failed"\n            attempt_info["error"] = str(error)\n            attempt_info["error_code"] = getattr(error, \'code\', \'UNKNOWN\')\n            \n            state["error"] = str(error)\n        \n        state["payment_attempts"].append(attempt_info)\n        return state\n    \n    def route_payment_result(self, state: WorkflowState) -> str:\n        """Route based on payment result"""\n        \n        last_attempt = state["payment_attempts"][-1]\n        \n        if last_attempt["status"] == "success":\n            return "success"\n        elif state["retry_count"] < state["max_retries"]:\n            return "retry"\n        else:\n            return "failed"\n    \n    async def handle_payment_failure(self, state: WorkflowState) -> WorkflowState:\n        """Analyze failure and determine retry strategy"""\n        \n        last_attempt = state["payment_attempts"][-1]\n        error_code = last_attempt.get("error_code", "UNKNOWN")\n        \n        print(f"\ud83d\udd0d Analyzing failure: {error_code}")\n        \n        # Determine retry strategy based on error type\n        if error_code == "INSUFFICIENT_FUNDS":\n            # Try cheaper alternative\n            state["retry_strategy"] = RetryStrategy.ALTERNATIVE_SERVICE\n            print("\ud83d\udca1 Strategy: Try cheaper service")\n            \n        elif error_code == "NETWORK_ERROR":\n            # Network issues - use exponential backoff\n            state["retry_strategy"] = RetryStrategy.EXPONENTIAL_BACKOFF\n            print("\ud83d\udca1 Strategy: Exponential backoff retry")\n            \n        elif error_code == "API_UNAVAILABLE":\n            # Service down - try alternative\n            state["retry_strategy"] = RetryStrategy.ALTERNATIVE_SERVICE\n            print("\ud83d\udca1 Strategy: Switch to alternative service")\n            \n        elif error_code == "RATE_LIMITED":\n            # Rate limited - wait and retry\n            state["retry_strategy"] = RetryStrategy.LINEAR_BACKOFF\n            print("\ud83d\udca1 Strategy: Linear backoff retry")\n            \n        else:\n            # Unknown error - try fallback\n            state["retry_strategy"] = RetryStrategy.ALTERNATIVE_SERVICE\n            print("\ud83d\udca1 Strategy: Use fallback service")\n        \n        return state\n    \n    def route_failure_handling(self, state: WorkflowState) -> str:\n        """Route failure handling based on strategy"""\n        \n        strategy = state["retry_strategy"]\n        \n        if strategy == RetryStrategy.EXPONENTIAL_BACKOFF:\n            return "backoff"\n        elif strategy == RetryStrategy.LINEAR_BACKOFF:\n            return "backoff"\n        elif strategy == RetryStrategy.ALTERNATIVE_SERVICE:\n            # Check if we have alternatives\n            current_index = state["fallback_services"].index(state["current_service"])\n            if current_index < len(state["fallback_services"]) - 1:\n                return "alternative"\n            else:\n                return "fallback"\n        else:\n            return "give_up"\n    \n    async def retry_with_backoff(self, state: WorkflowState) -> WorkflowState:\n        """Implement backoff retry logic"""\n        \n        strategy = state["retry_strategy"]\n        state["retry_count"] += 1\n        \n        if strategy == RetryStrategy.EXPONENTIAL_BACKOFF:\n            # Exponential backoff: 2^attempt seconds\n            delay = 2 ** state["retry_count"]\n            print(f"\u23f3 Exponential backoff: waiting {delay} seconds...")\n            \n        elif strategy == RetryStrategy.LINEAR_BACKOFF:\n            # Linear backoff: attempt * 5 seconds\n            delay = state["retry_count"] * 5\n            print(f"\u23f3 Linear backoff: waiting {delay} seconds...")\n            \n        else:\n            delay = 1\n        \n        # Wait for the calculated delay\n        await asyncio.sleep(min(delay, 60))  # Cap at 60 seconds\n        \n        print(f"\ud83d\udd04 Retry attempt #{state[\'retry_count\']} starting...")\n        return state\n    \n    async def try_alternative_service(self, state: WorkflowState) -> WorkflowState:\n        """Switch to the next service in the fallback chain"""\n        \n        current_index = state["fallback_services"].index(state["current_service"])\n        next_index = current_index + 1\n        \n        if next_index < len(state["fallback_services"]):\n            old_service = state["current_service"]\n            state["current_service"] = state["fallback_services"][next_index]\n            state["retry_count"] = 0  # Reset retry count for new service\n            \n            print(f"\ud83d\udd04 Switching from {old_service} to {state[\'current_service\']}")\n            \n            # Log the service switch\n            switch_info = {\n                "type": "service_switch",\n                "from": old_service,\n                "to": state["current_service"],\n                "reason": "payment_failure",\n                "timestamp": datetime.now().isoformat()\n            }\n            state["payment_attempts"].append(switch_info)\n        else:\n            print("\u274c No more alternative services available")\n            state["error"] = "All services exhausted"\n        \n        return state\n    \n    async def use_fallback_service(self, state: WorkflowState) -> WorkflowState:\n        """Use the final fallback service (usually free)"""\n        \n        state["current_service"] = state["fallback_services"][-1]  # Last service (free)\n        state["retry_count"] = 0\n        \n        print(f"\ud83c\udd98 Using final fallback: {state[\'current_service\']}")\n        \n        return state\n    \n    async def complete_task(self, state: WorkflowState) -> WorkflowState:\n        """Task completed successfully"""\n        \n        service_config = self.get_service_config(state["current_service"])\n        \n        print(f"\u2705 Task completed successfully!")\n        print(f"\ud83d\udcca Service used: {service_config[\'name\']}")\n        print(f"\ud83d\udcb0 Total cost: ${state[\'total_cost\']}")\n        print(f"\ud83d\udd04 Total attempts: {len(state[\'payment_attempts\'])}")\n        \n        # Generate completion summary\n        state["completion_summary"] = {\n            "success": True,\n            "service_used": state["current_service"],\n            "total_cost": state["total_cost"],\n            "attempts": len(state["payment_attempts"]),\n            "retry_count": state["retry_count"]\n        }\n        \n        return state\n    \n    async def handle_final_failure(self, state: WorkflowState) -> WorkflowState:\n        """Handle final failure when all retries exhausted"""\n        \n        print(f"\u274c Task failed after all retry attempts")\n        print(f"\ud83d\udd04 Total attempts: {len(state[\'payment_attempts\'])}")\n        print(f"\ud83d\udcb0 Total cost (partial): ${state[\'total_cost\']}")\n        \n        # Generate failure summary\n        state["completion_summary"] = {\n            "success": False,\n            "final_error": state.get("error", "Unknown error"),\n            "total_cost": state["total_cost"],\n            "attempts": len(state["payment_attempts"]),\n            "services_tried": list(set([\n                attempt.get("service") for attempt in state["payment_attempts"] \n                if attempt.get("service")\n            ]))\n        }\n        \n        return state\n    \n    def get_service_config(self, service_name: str) -> dict:\n        """Get configuration for a service"""\n        \n        configs = {\n            "premium_ai_service": {\n                "name": "Premium AI Service",\n                "url": "https://premium-ai.com/api/analyze",\n                "cost": "10.00",\n                "quality": "excellent",\n                "features": ["advanced_reasoning", "multimodal", "real_time"]\n            },\n            "standard_ai_service": {\n                "name": "Standard AI Service", \n                "url": "https://standard-ai.com/api/process",\n                "cost": "5.00",\n                "quality": "good",\n                "features": ["standard_reasoning", "text_only"]\n            },\n            "basic_ai_service": {\n                "name": "Basic AI Service",\n                "url": "https://basic-ai.com/api/simple",\n                "cost": "2.00", \n                "quality": "adequate",\n                "features": ["basic_processing"]\n            },\n            "free_service": {\n                "name": "Free Community Service",\n                "url": "https://free-ai.com/api/community",\n                "cost": "0.00",\n                "quality": "basic",\n                "features": ["limited_processing"]\n            }\n        }\n        \n        return configs.get(service_name, configs["free_service"])\n    \n    async def call_free_service(self, service_config: dict, task: str) -> dict:\n        """Simulate calling a free service"""\n        \n        print(f"\ud83c\udd93 Using free service: {service_config[\'name\']}")\n        \n        # Simulate processing delay\n        await asyncio.sleep(2)\n        \n        return {\n            "result": f"Basic analysis of: {task}",\n            "quality": "basic",\n            "service": service_config["name"],\n            "cost": 0.00\n        }\n\n# Usage example\nasync def run_retry_example():\n    """Run the payment retry workflow example"""\n    \n    workflow = PaymentRetryWorkflow("retry_demo_agent")\n    \n    # Example task that might require multiple retry attempts\n    initial_state = {\n        "task": "Analyze customer sentiment from 10,000 reviews and generate insights"\n    }\n    \n    print("\ud83d\ude80 Starting Payment Retry Workflow Demo")\n    print("=" * 50)\n    \n    try:\n        final_state = await workflow.workflow.ainvoke(initial_state)\n        \n        print("\\n\ud83d\udccb Final Results:")\n        print("=" * 20)\n        \n        if final_state["completion_summary"]["success"]:\n            print("\u2705 Workflow completed successfully")\n            print(f"\ud83d\udcca Result: {final_state[\'result\'][\'result\']}")\n        else:\n            print("\u274c Workflow failed")\n            print(f"\ud83d\udd0d Final error: {final_state[\'completion_summary\'][\'final_error\']}")\n        \n        # Display payment attempt log\n        print(f"\\n\ud83d\udcb3 Payment Attempts Log:")\n        for i, attempt in enumerate(final_state["payment_attempts"], 1):\n            if attempt.get("type") == "service_switch":\n                print(f"  {i}. \ud83d\udd04 Service switch: {attempt[\'from\']} \u2192 {attempt[\'to\']}")\n            else:\n                status_icon = "\u2705" if attempt["status"] == "success" else "\u274c"\n                print(f"  {i}. {status_icon} {attempt[\'service\']}: ${attempt[\'amount\']} ({attempt[\'status\']})")\n        \n        print(f"\\n\ud83d\udcb0 Total Cost: ${final_state[\'total_cost\']}")\n        \n    except Exception as error:\n        print(f"\u274c Workflow execution failed: {error}")\n\n# Advanced retry strategies\nclass AdvancedRetryStrategies:\n    """Advanced retry strategies for different scenarios"""\n    \n    @staticmethod\n    async def adaptive_retry(workflow_state: WorkflowState, failure_history: List[dict]) -> RetryStrategy:\n        """Choose retry strategy based on historical failure patterns"""\n        \n        # Analyze recent failures\n        recent_failures = failure_history[-5:]  # Last 5 failures\n        error_counts = {}\n        \n        for failure in recent_failures:\n            error_code = failure.get("error_code", "UNKNOWN")\n            error_counts[error_code] = error_counts.get(error_code, 0) + 1\n        \n        # Choose strategy based on predominant error type\n        if error_counts.get("NETWORK_ERROR", 0) > 2:\n            return RetryStrategy.EXPONENTIAL_BACKOFF\n        elif error_counts.get("RATE_LIMITED", 0) > 1:\n            return RetryStrategy.LINEAR_BACKOFF\n        elif error_counts.get("INSUFFICIENT_FUNDS", 0) > 0:\n            return RetryStrategy.ALTERNATIVE_SERVICE\n        else:\n            return RetryStrategy.EXPONENTIAL_BACKOFF\n    \n    @staticmethod\n    async def cost_aware_retry(\n        workflow_state: WorkflowState, \n        budget_limit: float\n    ) -> bool:\n        """Determine if retry should continue based on cost constraints"""\n        \n        remaining_budget = budget_limit - workflow_state["total_cost"]\n        next_service_cost = 0.0\n        \n        # Calculate cost of next retry attempt\n        current_service_index = workflow_state["fallback_services"].index(\n            workflow_state["current_service"]\n        )\n        \n        if current_service_index < len(workflow_state["fallback_services"]) - 1:\n            next_service = workflow_state["fallback_services"][current_service_index + 1]\n            next_service_cost = float(\n                PaymentRetryWorkflow(None).get_service_config(next_service)["cost"]\n            )\n        \n        return remaining_budget >= next_service_cost\n    \n    @staticmethod\n    async def quality_threshold_retry(\n        workflow_state: WorkflowState,\n        minimum_quality: str\n    ) -> bool:\n        """Determine if retry should continue based on quality requirements"""\n        \n        quality_hierarchy = ["basic", "adequate", "good", "excellent"]\n        min_quality_index = quality_hierarchy.index(minimum_quality)\n        \n        current_service_config = PaymentRetryWorkflow(None).get_service_config(\n            workflow_state["current_service"]\n        )\n        current_quality_index = quality_hierarchy.index(\n            current_service_config["quality"]\n        )\n        \n        # Continue retrying if current service quality is below threshold\n        return current_quality_index < min_quality_index\n\n# Monitoring and analytics for retry workflows\nclass RetryAnalytics:\n    """Analytics for payment retry workflows"""\n    \n    def __init__(self):\n        self.retry_stats = {}\n    \n    def analyze_retry_patterns(self, workflow_states: List[WorkflowState]) -> dict:\n        """Analyze retry patterns across multiple workflow executions"""\n        \n        analysis = {\n            "total_workflows": len(workflow_states),\n            "success_rate": 0,\n            "average_retries": 0,\n            "common_failure_points": {},\n            "cost_analysis": {\n                "average_cost": 0,\n                "cost_by_service": {},\n                "cost_efficiency": 0\n            },\n            "service_reliability": {}\n        }\n        \n        successful_workflows = 0\n        total_retries = 0\n        total_cost = 0\n        \n        for state in workflow_states:\n            if state.get("completion_summary", {}).get("success"):\n                successful_workflows += 1\n            \n            total_retries += state.get("retry_count", 0)\n            total_cost += state.get("total_cost", 0)\n            \n            # Analyze failure points\n            for attempt in state.get("payment_attempts", []):\n                if attempt.get("status") == "failed":\n                    error_code = attempt.get("error_code", "UNKNOWN")\n                    analysis["common_failure_points"][error_code] = \\\n                        analysis["common_failure_points"].get(error_code, 0) + 1\n                \n                # Service reliability\n                service = attempt.get("service")\n                if service:\n                    if service not in analysis["service_reliability"]:\n                        analysis["service_reliability"][service] = {\n                            "attempts": 0,\n                            "successes": 0,\n                            "reliability": 0\n                        }\n                    \n                    analysis["service_reliability"][service]["attempts"] += 1\n                    if attempt.get("status") == "success":\n                        analysis["service_reliability"][service]["successes"] += 1\n        \n        # Calculate metrics\n        analysis["success_rate"] = successful_workflows / len(workflow_states) * 100\n        analysis["average_retries"] = total_retries / len(workflow_states)\n        analysis["cost_analysis"]["average_cost"] = total_cost / len(workflow_states)\n        \n        # Calculate service reliability percentages\n        for service, stats in analysis["service_reliability"].items():\n            if stats["attempts"] > 0:\n                stats["reliability"] = (stats["successes"] / stats["attempts"]) * 100\n        \n        return analysis\n    \n    def generate_retry_recommendations(self, analysis: dict) -> List[str]:\n        """Generate recommendations based on retry analysis"""\n        \n        recommendations = []\n        \n        # Success rate recommendations\n        if analysis["success_rate"] < 80:\n            recommendations.append(\n                "Consider increasing retry limits or improving service reliability"\n            )\n        \n        # Cost optimization recommendations\n        if analysis["cost_analysis"]["average_cost"] > 5.0:\n            recommendations.append(\n                "Review service hierarchy to prioritize cost-effective options"\n            )\n        \n        # Service reliability recommendations\n        unreliable_services = [\n            service for service, stats in analysis["service_reliability"].items()\n            if stats["reliability"] < 70\n        ]\n        \n        if unreliable_services:\n            recommendations.append(\n                f"Consider replacing unreliable services: {\', \'.join(unreliable_services)}"\n            )\n        \n        # Common failure recommendations\n        if "INSUFFICIENT_FUNDS" in analysis["common_failure_points"]:\n            recommendations.append(\n                "Implement automatic wallet funding or better balance monitoring"\n            )\n        \n        if "NETWORK_ERROR" in analysis["common_failure_points"]:\n            recommendations.append(\n                "Implement better network error handling and longer timeouts"\n            )\n        \n        return recommendations\n\nif __name__ == "__main__":\n    import asyncio\n    asyncio.run(run_retry_example())\n'})}),"\n",(0,a.jsx)(t.h2,{id:"key-features-demonstrated",children:"Key Features Demonstrated"}),"\n",(0,a.jsxs)(t.h3,{id:"1-intelligent-retry-logic",children:["1. ",(0,a.jsx)(t.strong,{children:"Intelligent Retry Logic"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Exponential backoff for network errors"}),"\n",(0,a.jsx)(t.li,{children:"Linear backoff for rate limiting"}),"\n",(0,a.jsx)(t.li,{children:"Immediate alternative service switching for cost issues"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"2-service-fallback-chain",children:["2. ",(0,a.jsx)(t.strong,{children:"Service Fallback Chain"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Premium \u2192 Standard \u2192 Basic \u2192 Free service progression"}),"\n",(0,a.jsx)(t.li,{children:"Automatic cost optimization"}),"\n",(0,a.jsx)(t.li,{children:"Quality-aware service selection"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"3-error-categorization",children:["3. ",(0,a.jsx)(t.strong,{children:"Error Categorization"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Different strategies for different error types"}),"\n",(0,a.jsx)(t.li,{children:"Historical pattern analysis"}),"\n",(0,a.jsx)(t.li,{children:"Adaptive retry behavior"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"4-cost-management",children:["4. ",(0,a.jsx)(t.strong,{children:"Cost Management"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Budget-aware retry decisions"}),"\n",(0,a.jsx)(t.li,{children:"Cost tracking across attempts"}),"\n",(0,a.jsx)(t.li,{children:"Service cost optimization"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"5-comprehensive-logging",children:["5. ",(0,a.jsx)(t.strong,{children:"Comprehensive Logging"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Detailed attempt tracking"}),"\n",(0,a.jsx)(t.li,{children:"Payment receipt management"}),"\n",(0,a.jsx)(t.li,{children:"Performance analytics"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,a.jsx)(t.h3,{id:"basic-retry-workflow-1",children:"Basic Retry Workflow"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# Simple usage with default settings\nworkflow = PaymentRetryWorkflow("my_agent")\n\nresult = await workflow.workflow.ainvoke({\n    "task": "Analyze this dataset for trends and patterns"\n})\n\nprint(f"Success: {result[\'completion_summary\'][\'success\']}")\nprint(f"Total cost: ${result[\'total_cost\']}")\n'})}),"\n",(0,a.jsx)(t.h3,{id:"advanced-configuration",children:"Advanced Configuration"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# Workflow with custom retry parameters\nworkflow = PaymentRetryWorkflow("advanced_agent")\n\n# Custom configuration\ncustom_state = {\n    "task": "Generate comprehensive market analysis",\n    "max_retries": 3,\n    "budget_limit": 15.00,\n    "quality_threshold": "good",\n    "preferred_services": [\n        "premium_analysis_service",\n        "standard_analysis_service", \n        "basic_analysis_service"\n    ]\n}\n\nresult = await workflow.workflow.ainvoke(custom_state)\n'})}),"\n",(0,a.jsx)(t.h3,{id:"integration-with-monitoring",children:"Integration with Monitoring"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# With analytics and monitoring\nanalytics = RetryAnalytics()\nresults = []\n\n# Run multiple workflows\nfor task in task_list:\n    result = await workflow.workflow.ainvoke({"task": task})\n    results.append(result)\n\n# Analyze patterns\nanalysis = analytics.analyze_retry_patterns(results)\nrecommendations = analytics.generate_retry_recommendations(analysis)\n\nprint("Retry Analysis:", analysis)\nprint("Recommendations:", recommendations)\n'})}),"\n",(0,a.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(t.h3,{id:"1-service-hierarchy-design",children:["1. ",(0,a.jsx)(t.strong,{children:"Service Hierarchy Design"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Order services by cost-effectiveness"}),"\n",(0,a.jsx)(t.li,{children:"Include at least one free fallback option"}),"\n",(0,a.jsx)(t.li,{children:"Balance cost vs. quality considerations"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"2-error-handling-strategy",children:["2. ",(0,a.jsx)(t.strong,{children:"Error Handling Strategy"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Categorize errors by retry-ability"}),"\n",(0,a.jsx)(t.li,{children:"Implement appropriate backoff strategies"}),"\n",(0,a.jsx)(t.li,{children:"Set reasonable retry limits"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"3-cost-optimization",children:["3. ",(0,a.jsx)(t.strong,{children:"Cost Optimization"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Monitor total costs across retries"}),"\n",(0,a.jsx)(t.li,{children:"Implement budget constraints"}),"\n",(0,a.jsx)(t.li,{children:"Track cost-effectiveness metrics"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"4-quality-assurance",children:["4. ",(0,a.jsx)(t.strong,{children:"Quality Assurance"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Define minimum quality thresholds"}),"\n",(0,a.jsx)(t.li,{children:"Validate results before completing"}),"\n",(0,a.jsx)(t.li,{children:"Implement quality-based routing"}),"\n"]}),"\n",(0,a.jsxs)(t.h3,{id:"5-monitoring-and-analytics",children:["5. ",(0,a.jsx)(t.strong,{children:"Monitoring and Analytics"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Track retry patterns and success rates"}),"\n",(0,a.jsx)(t.li,{children:"Monitor service reliability"}),"\n",(0,a.jsx)(t.li,{children:"Generate actionable recommendations"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/docs/integrations/langgraph",children:"LangGraph Integration Guide"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/docs/tools/pay_api_endpoint",children:"Payment Tools Reference"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/docs/security",children:"Error Handling Best Practices"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/docs/architecture",children:"Cost Optimization Strategies"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"support",children:"Support"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://discord.gg/langgraph",children:"LangGraph Community"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://discord.gg/paystabl",children:"PayStabl Discord"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://github.com/paystabl/examples",children:"GitHub Examples"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"mailto:support@paystabl.com",children:"Email Support"})}),"\n"]})]})}function f(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var r=n(6540);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);